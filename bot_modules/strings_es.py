# --- General ---
ERROR_GENERIC = "Ocurri√≥ un error inesperado."
ERROR_PROCESSING_REQUEST = "Ocurri√≥ un error al procesar tu solicitud."
ERROR_TRY_AGAIN_LATER = "Por favor, int√©ntalo de nuevo m√°s tarde."
OPERATION_CANCELED = "Operaci√≥n cancelada."
ACTION_NOT_RECOGNIZED = "Acci√≥n no reconocida."
BOT_IS_RUNNING = '¬°El bot est√° funcionando!'

# --- Configuration Loading ---
LOG_DOTENV_LOADED = "Archivo .env cargado (override=True)"
LOG_RAW_DEBUG_MODE = "Cadena DEBUG_MODE cruda del entorno: '{raw_value}'"
LOG_DEBUG_MODE_EVALUATED = "DEBUG_MODE evaluado como: {debug_mode}"
DEBUG_MODE_ON = "¬°Modo de depuraci√≥n ACTIVADO!"
DEBUG_MODE_OFF = "¬°Modo de depuraci√≥n DESACTIVADO!"
ERROR_TOKEN_NOT_SET = "La variable de entorno TELEGRAM_BOT_TOKEN no est√° configurada"
WARN_BASE_URL_NOT_SET = "La variable de entorno BASE_URL no est√° configurada. Intentando inferir..."
WARN_INFERRED_BASE_URL = "BASE_URL inferida como {base_url}. Config√∫rala expl√≠citamente en .env para producci√≥n."
WARN_GOOGLE_CREDS_NOT_SET = "La variable de entorno GOOGLE_APPLICATION_CREDENTIALS no est√° configurada o el archivo no existe. Algunas funciones de la API de Google podr√≠an no funcionar."
WARN_GOOGLE_FORM_ID_NOT_SET = "No se pudo obtener GOOGLE_FORM_ID. La recuperaci√≥n de formularios no funcionar√°."
LOG_GOOGLE_FORM_ID_SUCCESS = "GOOGLE_FORM_ID obtenido con √©xito: {form_id}" # Corrected typo GOOLGE -> GOOGLE
WARN_APPS_SCRIPT_ID_NOT_SET = "La variable de entorno APPS_SCRIPT_ID no est√° configurada. La recuperaci√≥n de Google Sheet no funcionar√°."
LOG_APPS_SCRIPT_ID_SUCCESS = "APPS_SCRIPT_ID obtenido con √©xito: {script_id}"
WARN_APPS_SCRIPT_WEB_APP_NOT_SET = "Las variables de entorno APPS_SCRIPT_WEB_APP_URL o APPS_SCRIPT_API_KEY no est√°n configuradas. La recuperaci√≥n de Google Sheet a trav√©s de la Aplicaci√≥n Web no funcionar√°."
LOG_APPS_SCRIPT_WEB_APP_SUCCESS = "APPS_SCRIPT_WEB_APP_URL obtenida con √©xito."

# --- Database ---
LOG_DB_INIT_SUCCESS = "Base de datos inicializada con √©xito"
LOG_DB_SAVED_MESSAGE = "Mensaje guardado del usuario {user_id}: {text_preview}..."
LOG_DB_SAVED_MEDIA_MESSAGE = "Mensaje {message_type} guardado del usuario {user_id}"
LOG_DB_SAVED_PROCESSED_TEXT = "Texto '{message_type}' guardado en user_messages para el usuario {user_id}, message_id original {original_message_id}"
ERROR_DB_SAVING_PROCESSED_TEXT = "Error al guardar el texto '{message_type}' en user_messages para el usuario {user_id}: {db_err}"
LOG_DB_DELETED_USER_DATA = "Datos de usuario eliminados para user_id {user_id}: {messages_deleted} mensajes, {interactions_deleted} interacciones"
ERROR_DB_DELETING_USER_DATA = "Error al eliminar datos de usuario: {error}"
LOG_DB_RETRIEVED_HISTORY = "Se recuperaron {count} mensajes para el usuario {user_id}, incluyendo datos procesados/recuperados"
LOG_DB_INITIATING_IMAGE_RESULT_STORAGE = "Iniciando almacenamiento en base de datos para respuesta de API Gemini para user_id: {user_id}, message_id: {message_id}"
LOG_DB_IMAGE_RESULT_STORED = "Respuesta de API Gemini almacenada con √©xito en la base de datos (ID de registro: {record_id})"
ERROR_DB_SAVING_IMAGE_RESULT = "Error al guardar el resultado del procesamiento de imagen en la base de datos: {error}"
LOG_DB_SEARCHING_FORM_ID = "Buscando 'form=<ID>' en los √∫ltimos {search_limit} mensajes para el usuario {user_id}"
LOG_DB_FOUND_FORM_ID = "ID de respuesta encontrado: {response_id} en el mensaje: '{message_text}'"
WARN_DB_FORM_ID_NOT_FOUND = "No se pudo encontrar el patr√≥n 'form=<ID>' para el usuario {user_id}"
ERROR_DB_RETRIEVING_USERS = "Error al recuperar usuarios de la BD: {error}"
ERROR_DB_RETRIEVING_IMAGE_RESULTS = "Error al recuperar resultados de procesamiento de im√°genes de la BD: {error}"
ERROR_DB_RETRIEVING_MESSAGES = "Error al recuperar mensajes de usuario de la BD: {error}"
ERROR_DB_RETRIEVING_INTERACTIONS = "Error al recuperar interacciones de usuario de la BD: {error}"
ERROR_DB_UPDATING_PREFERENCE = "Fallo al actualizar la preferencia en la BD"
ERROR_DB_HEALTH_CHECK = "Error de BD en la comprobaci√≥n de estado: {error}"
DB_STATUS_OK = 'ok'
DB_STATUS_MISSING = 'faltante' # 'missing'
DB_STATUS_ERROR = 'error'
DB_DEFAULT_LANGUAGE = 'es' # Changed default to Spanish
DB_DEFAULT_THEME = 'default' # 'default'
DB_ACTION_TYPE_TEXT = 'texto' # 'text'
DB_ACTION_TYPE_PROCESSED_IMAGE = 'texto_procesado_de_imagen' # 'processed_text_from_image'
DB_ACTION_TYPE_RETRIEVED_SHEET = 'datos_hoja_calculo_recuperados' # 'retrieved_sheet_data'
DB_ACTION_TYPE_RETRIEVED_FORM = 'datos_formulario_recuperados' # 'retrieved_form_data'
DB_MESSAGE_TYPE_TEXT = 'text'
DB_MESSAGE_TYPE_PHOTO = 'photo'
DB_MESSAGE_TYPE_PROCESSED_IMAGE = 'processed_text_from_image'
DB_MESSAGE_TYPE_RETRIEVED_FORM = 'retrieved_form_data'
DB_MESSAGE_TYPE_RETRIEVED_SHEET = 'retrieved_sheet_data'
DB_MESSAGE_TYPE_DATA_ENTRY = 'data_entry' # New type for 'dato[s]' messages

# --- Google APIs ---
LOG_GETTING_GEMINI_CREDS = "Intentando obtener credenciales para la API Gemini..."
ERROR_SERVICE_ACCOUNT_NOT_FOUND = "Archivo de cuenta de servicio no encontrado en la ruta: {path}"
LOG_TRYING_GEMINI_SCOPE = "Intentando credenciales Gemini con el scope: {scope}"
LOG_REFRESHING_GEMINI_CREDS = "Refrescando credenciales Gemini con el scope: {scope}"
LOG_GEMINI_TOKEN_SUCCESS = "Token de acceso Gemini obtenido con √©xito, comienza con: {token_preview}"
WARN_GEMINI_NO_TOKEN = "No se obtuvo token con el scope: {scope}"
WARN_GEMINI_FAILED_TOKEN_SCOPE = "Fallo al obtener token con el scope {scope}: {error}"
ERROR_GEMINI_ALL_AUTH_FAILED = "Todos los intentos de autenticaci√≥n de la API Gemini fallaron"
ERROR_GETTING_GEMINI_CREDS = "Error al obtener credenciales Gemini: {error}"
LOG_GETTING_GOOGLE_API_CREDS = "Intentando obtener credenciales para las APIs de Google..."
LOG_REQUESTING_GOOGLE_API_CREDS = "Solicitando credenciales de API de Google con scopes: {scopes}"
LOG_GOOGLE_API_CREDS_CREATED = "Objeto de credenciales de API de Google creado desde el archivo: {path}"
LOG_REFRESHING_GOOGLE_API_CREDS = "Intentando refrescar las credenciales de la API de Google..."
LOG_GOOGLE_API_CREDS_REFRESHED = "Credenciales de la API de Google refrescadas con √©xito."
LOG_GOOGLE_API_TOKEN_SUCCESS = "Token de acceso de la API de Google obtenido, comienza con: {token_preview}"
LOG_GOOGLE_API_TOKEN_EXPIRY = "Hora de expiraci√≥n del token: {expiry_time}"
LOG_GOOGLE_API_TOKEN_NO_EXPIRY = "Hora de expiraci√≥n del token no disponible."
WARN_GOOGLE_API_NO_TOKEN = "Credenciales de API de Google refrescadas pero no se obtuvo token."
WARN_GOOGLE_API_REFRESH_FAILED = "Fallo al refrescar el token, pero continuando: {error}"
LOG_GOOGLE_API_CREDS_SUCCESS = "Credenciales obtenidas con √©xito para las APIs de Google."
ERROR_GETTING_GOOGLE_API_CREDS = "Error al obtener credenciales de API de Google: {error}"
LOG_GEMINI_REQUEST_INITIATED = "Iniciando solicitud a la API Gemini para imagen del user_id: {user_id}"
ERROR_GEMINI_AUTH_FAILED = "Fallo al obtener credenciales autenticadas para Gemini"
ERROR_GEMINI_AUTH_FAILED_MSG = "Fall√≥ la autenticaci√≥n."
ERROR_GEMINI_TOKEN_REFRESH_FAILED = "Fallo al obtener token de acceso despu√©s de refrescar para Gemini."
ERROR_GEMINI_TOKEN_REFRESH_FAILED_MSG = "Fall√≥ la actualizaci√≥n del token de autenticaci√≥n."
LOG_GEMINI_SENDING_IMAGE = "Enviando datos de imagen al endpoint de la API Gemini: {endpoint}"
LOG_GEMINI_USING_TOKEN = "Usando token que comienza con: {token_preview} para procesamiento de imagen"
LOG_GEMINI_RAW_RESPONSE = "Respuesta cruda recibida de la API Gemini (Estado: {status_code}): {text_preview}..."
LOG_GEMINI_RESPONSE_SUCCESS = "Respuesta recibida con √©xito de la API Gemini"
LOG_GEMINI_PARSED_SUCCESS = "Respuesta JSON parseada con √©xito"
ERROR_GEMINI_REQUEST_FAILED = "Error de solicitud HTTP al llamar a la API Gemini: {error}"
ERROR_GEMINI_REQUEST_FAILED_USER_MSG = "Error de red al comunicarse con el servicio de IA ({status_code}): {error_text_preview}"
ERROR_GEMINI_JSON_DECODE = "Error al parsear la respuesta JSON de Gemini: {error}"
ERROR_GEMINI_JSON_DECODE_USER_MSG = "Se recibi√≥ un formato de datos inv√°lido del servicio de IA."
ERROR_GEMINI_PROCESSING_IMAGE = "Error al procesar imagen con Gemini: {error}"
ERROR_GEMINI_PROCESSING_IMAGE_USER_MSG = "Ocurri√≥ un error inesperado durante el procesamiento de IA."
ERROR_GEMINI_EXTRACT_UNEXPECTED_TYPE = "Tipo de respuesta inesperado para la extracci√≥n: {type}"
ERROR_GEMINI_EXTRACT_INVALID_FORMAT = "Error: Formato de respuesta inv√°lido recibido."
WARN_GEMINI_RESPONSE_BLOCKED = "Respuesta de Gemini bloqueada. Raz√≥n: {reason}"
GEMINI_RESPONSE_BLOCKED_USER_MSG = "Contenido bloqueado por filtros de seguridad. Raz√≥n: {reason}. Detalles: {safety_ratings}"
WARN_GEMINI_NO_CANDIDATES = "No se encontraron candidatos ni raz√≥n de bloqueo en la respuesta de Gemini: {response}"
GEMINI_NO_TEXT_USER_MSG = "No se encontr√≥ contenido de texto en la respuesta de la IA."
WARN_GEMINI_NO_TEXT_EXTRACTED = "No se extrajo texto de las partes de la respuesta de Gemini."
LOG_GEMINI_EXTRACTED_PIPE_FORMAT = "El texto extra√≠do parece estar en formato separado por pipes (|)."
WARN_GEMINI_EXTRACTED_UNEXPECTED_FORMAT = "El texto extra√≠do podr√≠a no estar en el formato esperado separado por pipes: {text_preview}..."
ERROR_GEMINI_EXTRACTING_TEXT = "Error al extraer texto de la respuesta de Gemini: {error}"
ERROR_GEMINI_EXTRACTING_TEXT_USER_MSG = "Error al procesar el contenido de la respuesta de la IA."
LOG_GEMINI_TEXT_ANALYSIS_INITIATED = "Iniciando an√°lisis de texto con Gemini para el usuario {user_id}"
ERROR_GEMINI_TEXT_AUTH_FAILED = "Fallo al obtener credenciales autenticadas para el an√°lisis de texto de Gemini"
ERROR_GEMINI_TEXT_TOKEN_MISSING = "Credenciales obtenidas pero falta el token despu√©s de refrescar para el an√°lisis de texto de Gemini."
ERROR_GEMINI_TEXT_TOKEN_MISSING_MSG = "Problema con el token de autenticaci√≥n."
LOG_GEMINI_TEXT_USING_TOKEN = "Usando token que comienza con: {token_preview} para an√°lisis de texto"
LOG_GEMINI_TEXT_SENDING_REQUEST = "Enviando solicitud de an√°lisis de texto al endpoint de la API Gemini: {endpoint}"
LOG_GEMINI_TEXT_ANALYSIS_SUCCESS = "An√°lisis de Gemini recibido y extra√≠do con √©xito para el usuario {user_id}"
ERROR_GEMINI_TEXT_REQUEST_FAILED = "Error de solicitud HTTP al llamar a la API Gemini para an√°lisis de texto: {error}"
ERROR_GEMINI_TEXT_JSON_DECODE = "Error al parsear la respuesta JSON de Gemini para an√°lisis de texto: {error}"
ERROR_GEMINI_TEXT_PROCESSING = "Error al procesar texto con Gemini para el usuario {user_id}: {error}"
ERROR_GEMINI_TEXT_PROCESSING_USER_MSG = "Ocurri√≥ un error inesperado durante el an√°lisis de texto de IA."
LOG_FORM_RETRIEVAL_INITIATED = "Intentando recuperar la respuesta {response_id} del formulario {form_id}"
ERROR_FORM_AUTH_FAILED = "Fallo al obtener credenciales para la API de Google Forms."
ERROR_FORM_AUTH_FAILED_MSG = "Fall√≥ la autenticaci√≥n."
LOG_FORM_RETRIEVAL_SUCCESS = "Respuesta de formulario {response_id} recuperada con √©xito"
ERROR_FORM_API = "Error de la API de Google Forms: {status_code} - {error_message}"
ERROR_FORM_API_USER_MSG = "Error de API ({status_code}): {error_message}"
ERROR_FORM_NOT_FOUND_USER_MSG = "ID de respuesta '{response_id}' no encontrado en el formulario '{form_id}'."
ERROR_FORM_PERMISSION_DENIED_USER_MSG = "Permiso denegado. Aseg√∫rate de que la cuenta de servicio tenga acceso a las respuestas del formulario."
ERROR_FORM_UNEXPECTED = "Error inesperado al recuperar la respuesta del formulario: {error}"
LOG_APPS_SCRIPT_CALL_INITIATED = "Iniciando llamada a Apps Script ID: {script_id}, Funci√≥n: {function_name}"
LOG_APPS_SCRIPT_PARAMETERS = "Par√°metros de Apps Script: {parameters}"
ERROR_APPS_SCRIPT_AUTH_FAILED = "Fallo al obtener credenciales para la llamada a Apps Script."
ERROR_APPS_SCRIPT_AUTH_FAILED_MSG = "Fall√≥ la autenticaci√≥n. No se pudieron obtener las credenciales."
LOG_APPS_SCRIPT_USING_CREDS = "Usando credenciales para la cuenta de servicio: {email}"
LOG_APPS_SCRIPT_CREDS_DETAILS = "Credenciales v√°lidas: {valid}, Scopes: {scopes}"
LOG_APPS_SCRIPT_BUILDING_SERVICE = "Construyendo servicio de API de Apps Script (script, v1)..."
LOG_APPS_SCRIPT_SERVICE_BUILT = "Servicio de API de Apps Script construido con √©xito."
LOG_APPS_SCRIPT_EXECUTING = "Ejecutando funci√≥n de Apps Script '{function_name}'..."
LOG_APPS_SCRIPT_REQUEST_BODY = "Cuerpo de la solicitud de Apps Script: {request}"
LOG_APPS_SCRIPT_RESPONSE_RECEIVED = "Respuesta recibida de la ejecuci√≥n de Apps Script."
LOG_APPS_SCRIPT_RAW_RESPONSE = "Respuesta cruda de Apps Script: {response}"
ERROR_APPS_SCRIPT_EXECUTION = "Error de ejecuci√≥n de Apps Script: Tipo={error_type}, Mensaje={error_message}"
LOG_APPS_SCRIPT_STACKTRACE = "Stacktrace de Apps Script: {stacktrace}"
ERROR_APPS_SCRIPT_EXECUTION_USER_MSG = "Error durante la ejecuci√≥n del script: {error_message}"
ERROR_APPS_SCRIPT_AUTH_REQUIRED_USER_MSG = "Error de autorizaci√≥n dentro de Apps Script."
ERROR_APPS_SCRIPT_NOT_FOUND_USER_MSG = "Error dentro de Apps Script: '{function_name}' o c√≥digo relacionado no encontrado."
LOG_APPS_SCRIPT_EXECUTION_SUCCESS = "Ejecuci√≥n de Apps Script exitosa. Tipo de resultado: {type}"
LOG_APPS_SCRIPT_RESULT = "Resultado de Apps Script: {result}"
ERROR_APPS_SCRIPT_HTTP = "Error HTTP al llamar a la API de Apps Script: Estado={status_code}, Respuesta={error_content}"
ERROR_APPS_SCRIPT_HTTP_USER_MSG = "Ocurri√≥ un error de API ({status_code}). Revisa los logs para detalles."
ERROR_APPS_SCRIPT_HTTP_401_USER_MSG = "Fall√≥ la autenticaci√≥n (401)."
ERROR_APPS_SCRIPT_HTTP_403_USER_MSG = "Permiso denegado (403). Aseg√∫rate de que la API de Apps Script est√© habilitada y la cuenta de servicio tenga permiso."
ERROR_APPS_SCRIPT_HTTP_404_USER_MSG = "Proyecto de Apps Script (ID: {script_id}) no encontrado (404)."
ERROR_APPS_SCRIPT_HTTP_429_USER_MSG = "L√≠mite de tasa de API excedido (429)."
ERROR_APPS_SCRIPT_UNEXPECTED = "Error inesperado al llamar a Apps Script: {error}"
ERROR_APPS_SCRIPT_UNEXPECTED_USER_MSG = "Ocurri√≥ un error inesperado al comunicarse con el servicio de Apps Script."
LOG_WEB_APP_CALL_INITIATED = "Iniciando llamada a la Aplicaci√≥n Web de Apps Script para el ID: {id_to_find}"
ERROR_WEB_APP_NOT_CONFIGURED = "La URL de la Aplicaci√≥n Web o la Clave API no est√°n configuradas."
ERROR_WEB_APP_NOT_CONFIGURED_USER_MSG = "La recuperaci√≥n mediante Aplicaci√≥n Web no est√° configurada en el servidor."
LOG_WEB_APP_MAKING_REQUEST = "Realizando solicitud GET a la URL de la Aplicaci√≥n Web (par√°metros omitidos por seguridad)"
LOG_WEB_APP_ATTEMPTING_GET = "Intentando requests.get a {target_url} con timeout=30..."
LOG_WEB_APP_GET_COMPLETED = "Llamada requests.get completada. C√≥digo de estado recibido: {status_code}"
LOG_WEB_APP_RESPONSE_RECEIVED = "Respuesta recibida de la Aplicaci√≥n Web. Estado: {status_code}, Content-Type: {content_type}"
LOG_WEB_APP_RAW_RESPONSE = "Texto de respuesta crudo (primeros 500 caracteres): {text_preview}"
WARN_WEB_APP_NOT_FOUND = "La Aplicaci√≥n Web devolvi√≥ 'No Encontrado' para el ID: {id_to_find}"
WEB_APP_NOT_FOUND_USER_MSG = "ID '{id_to_find}' no encontrado en la Google Sheet."
ERROR_WEB_APP_UNAUTHORIZED = "La Aplicaci√≥n Web devolvi√≥ 'No Autorizado'. Verifica la Clave API."
WEB_APP_UNAUTHORIZED_USER_MSG = "Autorizaci√≥n fallida. Clave API inv√°lida proporcionada a la Aplicaci√≥n Web."
ERROR_WEB_APP_BAD_REQUEST = "La Aplicaci√≥n Web devolvi√≥ 'Solicitud Incorrecta'. Verifica si el par√°metro 'id' falta o es inv√°lido."
WEB_APP_BAD_REQUEST_USER_MSG = "Solicitud incorrecta enviada a la Aplicaci√≥n Web (ej., ID faltante)."
LOG_WEB_APP_JSON_PARSED = "Respuesta JSON de la Aplicaci√≥n Web parseada con √©xito para el ID: {id_to_find}"
ERROR_WEB_APP_JSON_DECODE = "Fallo al decodificar la respuesta JSON de la Aplicaci√≥n Web: {error}"
ERROR_WEB_APP_JSON_DECODE_TEXT = "El texto de la respuesta fue: {text}"
WEB_APP_INVALID_DATA_USER_MSG = "Se recibi√≥ un formato de datos inv√°lido de la Aplicaci√≥n Web."
ERROR_WEB_APP_TIMEOUT = "La solicitud a la Aplicaci√≥n Web expir√≥ para el ID: {id_to_find}"
WEB_APP_TIMEOUT_USER_MSG = "La solicitud a la Aplicaci√≥n Web expir√≥ (timeout)."
ERROR_WEB_APP_REQUEST_FAILED = "Error de solicitud HTTP al llamar a la Aplicaci√≥n Web: {error}"
WEB_APP_REQUEST_FAILED_USER_MSG = "Error de red al comunicarse con la Aplicaci√≥n Web: {error}"
WEB_APP_REQUEST_FAILED_401_USER_MSG = "Acceso denegado a la Aplicaci√≥n Web (401). Verifica permisos/despliegue del script."
WEB_APP_REQUEST_FAILED_403_USER_MSG = "Aplicaci√≥n Web prohibida (403). Verifica la clave API o el acceso del script."
WEB_APP_REQUEST_FAILED_404_USER_MSG = "URL de la Aplicaci√≥n Web no encontrada (404)."
WEB_APP_REQUEST_FAILED_500_USER_MSG = "Error dentro del script de la Aplicaci√≥n Web (500)."
ERROR_WEB_APP_UNEXPECTED = "Error inesperado al recuperar datos v√≠a Aplicaci√≥n Web: {error}"
WEB_APP_UNEXPECTED_USER_MSG = "Ocurri√≥ un error inesperado al contactar la Aplicaci√≥n Web."
GEMINI_PROMPT_IMAGE_ANALYSIS = "Analiza la imagen y extrae la siguiente informaci√≥n personal: nombre completo, fecha de nacimiento, edad, correo electr√≥nico, n√∫mero de tel√©fono, ciudad, estado/provincia, g√©nero y m√©todo de contacto preferido. Devuelve la informaci√≥n extra√≠da como una **√∫nica cadena de texto** con **pares clave-valor separados por el s√≠mbolo de pipe (|)**. El formato debe ser: `clave=valor|clave=valor|clave=valor|...`. Usa las siguientes claves: `full_name`, `date_of_birth`, `age`, `email`, `phone_number`, `city`, `state`, `gender`, y `preferred_contact_method`. Por ejemplo: `full_name=LUIGI CADORNA|date_of_birth=8/2/1962|age=63|email=luigi.cadorna@ymail.com|phone_number=1234567890|city=Buenos Aires|state=JALISCO|gender=Male|preferred_contact_method=Mail` Si alguna pieza de informaci√≥n no puede ser extra√≠da con confianza de la imagen, deja el valor correspondiente **vac√≠o** (para cadenas de texto) o `null` (para n√∫meros como la edad), pero incluye igualmente la clave en la cadena de salida. Por ejemplo, si no se encuentra el correo electr√≥nico, deber√≠a ser `email=|...` y si no se encuentra la edad, deber√≠a ser `age=null|...`. Aseg√∫rate de que la respuesta sea **√∫nicamente la cadena de texto** con los pares clave-valor separados por pipes, sin ning√∫n formato markdown, bloques de c√≥digo o texto adicional."
GEMINI_PROMPT_TEXT_ANALYSIS = "Analiza los siguientes mensajes de usuario y comprueba si hay preguntas o instrucciones sobre lo que debes hacer. Tu respuesta debe incluir la(s) respuesta(s) a todas las preguntas e instrucciones. Mant√©n tu respuesta concisa y amigable y SIEMPRE en espa√±ol:\n\n"
API_SCOPE_CLOUD_PLATFORM = "https://www.googleapis.com/auth/cloud-platform"
API_SCOPE_AI_PLATFORM = "https://www.googleapis.com/auth/aiplatform"
API_SCOPE_GENERATIVE_AI = "https://www.googleapis.com/auth/generative-ai"
API_SCOPE_FORMS_READONLY = "https://www.googleapis.com/auth/forms.responses.readonly"
API_SCOPE_SCRIPT_EXECUTE = "https://www.googleapis.com/auth/script.execute"

# --- Utils ---
LOG_CLEANUP_SKIPPED_NO_PATH = "Limpieza omitida: No se proporcion√≥ ruta de archivo."
LOG_CLEANUP_INITIATED = "Iniciando limpieza de archivo temporal: {path}"
LOG_CLEANUP_SUCCESS = "Archivo temporal eliminado con √©xito: {path}"
WARN_CLEANUP_NOT_FOUND = "Limpieza omitida: Archivo no encontrado en {path}"
ERROR_CLEANUP_FAILED = "Error al limpiar archivo temporal {path}: {error}"

# --- Telegram Bot ---
LOG_MENU_GENERATION_DEBUG = "generate_main_menu: DEBUG_MODE={debug_mode}, BASE_URL='{base_url}'"
LOG_MENU_GENERATION_ADDING_WEBAPPS = "generate_main_menu: Se cumplen las condiciones para a√±adir botones de Aplicaci√≥n Web."
LOG_MENU_GENERATION_CHECKING_URL = "Comprobando URL de Mensajes: {url}"
LOG_MENU_GENERATION_ADDING_BUTTON = "generate_main_menu: A√±adiendo bot√≥n '{button_text}'."
LOG_MENU_GENERATION_ADDING_WEBAPP_BUTTONS = "generate_main_menu: Llamando a markup.add() con {count} bot√≥n(es) de aplicaci√≥n web."
WARN_MENU_GENERATION_NO_WEBAPP_BUTTONS = "generate_main_menu: No se crearon botones v√°lidos de Aplicaci√≥n Web, omitiendo markup.add()."
WARN_MENU_GENERATION_NO_HTTPS = "generate_main_menu: BASE_URL no est√° configurada o no usa HTTPS. Los botones de Aplicaci√≥n Web no se mostrar√°n."
LOG_MENU_GENERATION_DEBUG_SKIPPING_WEBAPPS = "generate_main_menu: DEBUG_MODE es True, omitiendo botones de Aplicaci√≥n Web."
LOG_SENT_MAIN_MENU = "Men√∫ principal enviado como nuevo mensaje al chat {chat_id}"
ERROR_SENDING_MAIN_MENU = "Fallo al enviar mensaje de men√∫ principal al chat {chat_id}: {error}"
LOG_IMAGE_DOWNLOAD_START = "Iniciando proceso de descarga de imagen para file_id: {file_id}, user_id: {user_id}, message_id: {message_id}"
LOG_IMAGE_DOWNLOAD_SUCCESS = "Imagen descargada con √©xito a {path} (Tama√±o: {size} bytes)"
ERROR_IMAGE_DOWNLOAD = "Error al descargar imagen: {error}"
LOG_SENT_GENERATED_FILE = "Archivo generado {filename} enviado al chat {chat_id}"
ERROR_GENERATING_FILE = "Error al generar/enviar archivo para el chat {chat_id}: {error}"
ERROR_GENERATING_FILE_USER_MSG = "Lo siento, no pude generar o enviar el archivo."
LOG_RECEIVED_COMMAND = "Comando /{command} recibido del usuario {user_id} en el chat {chat_id}"
LOG_SENT_WELCOME_MENU = "Mensaje de bienvenida con men√∫ principal enviado al usuario {user_id}"
ERROR_START_HELP_FAILED = "Error durante handle_start_help para el usuario {user_id}: {error}"
ERROR_START_HELP_USER_MSG = "Lo siento, algo sali√≥ mal. Por favor, intenta /start de nuevo m√°s tarde."
ERROR_SENDING_ERROR_MSG = "Fallo al enviar mensaje de error al usuario {user_id}: {error}"
LOG_RECEIVED_PHOTO = "Foto recibida del usuario {user_id} en el chat {chat_id}, message_id {message_id}"
PHOTO_NO_DATA_USER_MSG = "No pude encontrar datos de imagen en tu mensaje."
LOG_PHOTO_NO_DATA = 'mensaje_foto_sin_datos' # 'photo_message_no_data'
LOG_IMAGE_RECEIVED_DETAILS = "Imagen recibida del usuario {user_id}, ID de mensaje {message_id}. File ID: {file_id}"
PHOTO_PROCESSING_USER_MSG = "Procesando tu imagen..."
PHOTO_DOWNLOAD_FAILED_USER_MSG = "Lo siento, no pude descargar tu imagen."
LOG_DOWNLOAD_IMAGE_ERROR = 'error_descarga_imagen' # 'download_image_error'
LOG_IMAGE_PROCESSING_WORKFLOW_START = "Iniciando flujo de trabajo de procesamiento de imagen para el usuario {user_id}"
PHOTO_PROCESSING_FAILED_USER_MSG = "Lo siento, no pude procesar tu imagen. Error: {error_text}"
LOG_GEMINI_PROCESSING_ERROR = 'error_procesamiento_gemini' # 'gemini_processing_error'
LOG_EXTRACTED_TEXT_PREVIEW = "Texto extra√≠do de Gemini para el usuario {user_id}: {text_preview}..."
LOG_CONVERTED_TO_JSON = "Texto extra√≠do convertido a JSON con √©xito para el usuario {user_id}"
WARN_CONVERSION_INVALID_PAIR = "Omitiendo par inv√°lido '{pair}' en la respuesta de Gemini para el usuario {user_id}"
WARN_CONVERSION_NO_PAIRS = "No se pudieron parsear pares clave-valor v√°lidos de la respuesta de Gemini para el usuario {user_id}. Guardando texto original."
WARN_CONVERSION_NOT_PIPE_SEPARATED = "Texto extra√≠do para el usuario {user_id} no est√° separado por pipes. Guardando texto original."
ERROR_CONVERTING_TO_JSON = "Error al convertir cadena separada por pipes a JSON para el usuario {user_id}: {error}"
WARN_FAILED_SAVING_IMAGE_RESULT = "Fallo al guardar resultado de procesamiento de imagen en BD para el usuario {user_id}"
PHOTO_EXTRACTED_INFO_USER_MSG = "Informaci√≥n Extra√≠da:\n\n{result_text}"
WARN_TRUNCATED_MESSAGE = "Mensaje de texto extra√≠do largo truncado para el usuario {user_id}"
LOG_SENT_EXTRACTED_TEXT = 'texto_extraido_enviado' # 'sent_extracted_text'
LOG_IMAGE_PROCESSING_WORKFLOW_SUCCESS = "Flujo de trabajo de procesamiento de imagen completado con √©xito para el usuario {user_id}"
PHOTO_PROCESSED_NEXT_ACTION_USER_MSG = "Imagen procesada. ¬øQu√© te gustar√≠a hacer ahora?"
ERROR_IMAGE_WORKFLOW = "Error en el flujo de trabajo de procesamiento de imagen: {error}"
PHOTO_ERROR_USER_MSG = "Lo siento, ocurri√≥ un error mientras procesaba tu imagen."
LOG_PHOTO_WORKFLOW_ERROR = 'error_flujo_trabajo_foto' # 'photo_workflow_error'
LOG_IMAGE_WORKFLOW_CLEANUP_COMPLETE = "Limpieza del flujo de trabajo de procesamiento de imagen completada para el usuario {user_id}"
TEXT_UNKNOWN_COMMAND_USER_MSG = "Lo siento, no entiendo ese comando."
LOG_SKIPPED_MENU_FOR_COMMAND = "Se omiti√≥ el env√≠o del men√∫ principal desde handle_text para el comando '{command}' en el chat {chat_id}"
TEXT_HISTORY_HEADER = "üìù Tu historial de mensajes:\n\n"
TEXT_HISTORY_NO_PREVIOUS = "No se encontraron mensajes anteriores."
TEXT_RECEIVED_USER_MSG = "Recib√≠ tu mensaje."
TEXT_RECEIVED_NO_HISTORY_USER_MSG = "Recib√≠ tu mensaje. No se encontr√≥ historial."
LOG_SENT_MENU_AFTER_TEXT = "Men√∫ principal enviado despu√©s de manejar texto no-comando del chat {chat_id}"
LOG_BUTTON_CLICK = "clic_boton" # 'button_click'
LOG_USER_ACTION = "Usuario {user_id}: {action}"
LOG_CALLBACK_RETRIEVE_FORM = "Usuario {user_id}: Hizo clic en 'Recuperar Datos de Formulario'"
CALLBACK_FORM_NOT_CONFIGURED = "La recuperaci√≥n de formularios no est√° configurada."
CALLBACK_SEARCHING_FORM_ID = "Buscando ID de respuesta de formulario..."
CALLBACK_FORM_ID_NOT_FOUND = "No se pudo encontrar 'form=<n√∫mero>' en el historial reciente."
CALLBACK_FOUND_FORM_ID = "ID encontrado: {response_id}. Recuperando datos..."
CALLBACK_FORM_DATA_DISPLAY = "üìÑ Datos de Respuesta de Formulario (ID: {response_id}):\n\n```json\n{json_string}\n```"
CALLBACK_FORM_DATA_TRUNCATED = "... (truncado)\n```"
ERROR_DISPLAYING_FORM_DATA = "Error al formatear/mostrar datos del formulario: {error}"
CALLBACK_FORM_DISPLAY_ERROR_USER_MSG = "Datos recuperados para {response_id}, pero fall√≥ al mostrarlos."
CALLBACK_FORM_RETRIEVAL_FAILED_USER_MSG = "‚ùå Fallo al recuperar datos del formulario:\n{error_message}"
LOG_FORM_RETRIEVAL_SUCCESS = "exito_recuperacion_formulario" # 'form_retrieval_success'
LOG_FORM_RETRIEVAL_FAILED = "fallo_recuperacion_formulario" # 'form_retrieval_failed'
LOG_CALLBACK_RETRIEVE_SHEET = "Usuario {user_id}: Hizo clic en 'Recuperar Datos de Hoja de C√°lculo'"
CALLBACK_SHEET_NOT_CONFIGURED = "La recuperaci√≥n de hoja de c√°lculo v√≠a Aplicaci√≥n Web no est√° configurada."
CALLBACK_SEARCHING_SHEET_ID = "Buscando ID (form=<n√∫mero>)..."
LOG_CALLING_WEB_APP = "Llamando a get_sheet_data_via_webapp para el ID: {id_to_find}"
CALLBACK_SHEET_DATA_DISPLAY = "üìà Datos de Hoja de C√°lculo (ID: {id_to_find}):\n\n```json\n{json_string}\n```"
ERROR_DISPLAYING_SHEET_DATA = "Error al formatear/mostrar datos de la hoja de c√°lculo: {error}"
CALLBACK_SHEET_DISPLAY_ERROR_USER_MSG = "Datos de hoja de c√°lculo recuperados para {id_to_find}, pero fall√≥ al mostrarlos."
CALLBACK_SHEET_RETRIEVAL_FAILED_USER_MSG = "‚ùå Fallo al recuperar datos de la hoja de c√°lculo:\n{error_message}"
LOG_SHEET_RETRIEVAL_SUCCESS = "exito_recuperacion_hoja" # 'sheet_retrieval_success'
LOG_SHEET_RETRIEVAL_FAILED = "fallo_recuperacion_hoja" # 'sheet_retrieval_failed'
LOG_CALLBACK_VIEW_DATA = "Usuario {user_id}: Solicit√≥ ver sus datos"
CALLBACK_DATA_SUMMARY_HEADER = "üìä Resumen de Tus Datos\n\nPerfil:\n"
CALLBACK_DATA_SUMMARY_PROFILE = "‚Ä¢ Usuario: @{username}\n‚Ä¢ Nombre: {first_name} {last_name}\n‚Ä¢ Se uni√≥: {created_at}\n\nPreferencias:\n"
CALLBACK_DATA_SUMMARY_PREFS = "‚Ä¢ Idioma: {language}\n\nActividad:\n"
CALLBACK_DATA_SUMMARY_ACTIVITY = "‚Ä¢ Mensajes: {message_count}\n‚Ä¢ Interacciones: {interaction_count}\n\nMensajes Recientes:\n"
CALLBACK_DATA_SUMMARY_RECENT_MSG = "{index}. {text_preview}{ellipsis}\n"
CALLBACK_DATA_SUMMARY_NO_RECENT = "Ninguno\n"
CALLBACK_DATA_SUMMARY_NO_TEXT = "[Sin Texto/Media]" # Placeholder for None message text
CALLBACK_NO_DATA_FOUND = "No se encontraron datos."
LOG_CALLBACK_DELETE_DATA = "Usuario {user_id}: Solicit√≥ eliminaci√≥n de datos"
CALLBACK_DELETE_CONFIRMATION_USER_MSG = "‚ö†Ô∏è ¬øSeguro que quieres eliminar todos tus datos? No se puede deshacer."
LOG_CALLBACK_CONFIRM_DELETE = "Usuario {user_id}: Confirm√≥ eliminaci√≥n de datos"
CALLBACK_DELETE_SUCCESS_USER_MSG = "‚úÖ Datos eliminados ({msg_del} msgs, {int_del} interacciones). Usa /start de nuevo."
CALLBACK_DELETE_SUCCESS_NEXT_ACTION = "Datos eliminados. Elige una opci√≥n:"
CALLBACK_DELETE_ERROR_USER_MSG = "‚ùå Error al eliminar datos."
LOG_CALLBACK_CANCEL_DELETE = "Usuario {user_id}: Cancel√≥ eliminaci√≥n de datos"
LOG_CALLBACK_MENU1 = "Usuario {user_id}: Men√∫ 1 (Analizar Mensajes) seleccionado"
CALLBACK_ANALYZING_MESSAGES = "Analizando mensajes..."
CALLBACK_NO_MESSAGES_TO_ANALYZE = "No hay mensajes para analizar."
CALLBACK_ANALYSIS_PROMPT_JSON = "- Datos JSON: {formatted_json}\n"
CALLBACK_ANALYSIS_PROMPT_TEXT = "- {text}\n"
LOG_SENDING_PROMPT_TO_GEMINI = "Enviando prompt a Gemini para an√°lisis (usuario {user_id}): {prompt_preview}..."
CALLBACK_ANALYSIS_ERROR_USER_MSG = "Lo siento, no pude analizar los mensajes. Error: {error_text}"
CALLBACK_ANALYSIS_RESULT_USER_MSG = "üìä An√°lisis:\n\n{analysis_result}"
LOG_CALLBACK_MENU2 = "Usuario {user_id}: Men√∫ 2 seleccionado"
CALLBACK_MENU2_USER_MSG = "Men√∫ 2 seleccionado. Elige sub√≠tem:"
LOG_CALLBACK_MAIN_MENU = "Usuario {user_id}: Volvi√≥ al men√∫ principal"
CALLBACK_MAIN_MENU_USER_MSG = "Men√∫ Principal:"
LOG_CALLBACK_SUBMENU = "Usuario {user_id}: Procesando {callback_data}"
CALLBACK_PROCESSING_SUBMENU = "Procesando {callback_data}..."
CALLBACK_SUBMENU_PROCESSED_NEXT_ACTION = "{callback_data} procesado. Elige la siguiente opci√≥n:"
CALLBACK_SUBMENU_ACTION_PROCESSED = "Acci√≥n '{callback_data}' procesada."
WARN_UNHANDLED_CALLBACK = "Callback no manejado del usuario {user_id}: {callback_data}"
WARN_EDIT_MESSAGE_NOT_FOUND = "No se pudo editar el mensaje {message_id} para el chat {chat_id}. Podr√≠a haber sido eliminado o ser muy antiguo. Enviando nuevo mensaje en su lugar."
CALLBACK_DEFAULT_USER_MSG = "Por favor, elige una opci√≥n:"
ERROR_CALLBACK_API = "Error de API de Telegram manejando callback '{callback_data}' para usuario {user_id}: {api_ex}"
ERROR_CALLBACK_API_USER_MSG = "Lo siento, ocurri√≥ un error de Telegram."
ERROR_CALLBACK_GENERAL = "Error manejando consulta de callback '{callback_data}' para usuario {user_id}: {error}"
ERROR_CALLBACK_GENERAL_USER_MSG = "Ocurri√≥ un error procesando tu solicitud."
ERROR_CALLBACK_GENERAL_EDIT_MSG = "Ocurri√≥ un error. Por favor, int√©ntalo de nuevo."
ERROR_SENDING_CALLBACK_FEEDBACK = "Fallo al enviar feedback de error para callback '{callback_data}' al usuario {user_id}: {nested_error}"
BUTTON_ANALYZE_MESSAGES = "üìä Analizar Mis Mensajes"
BUTTON_RETRIEVE_FORM = "üìÑ Recuperar Datos de Formulario"
BUTTON_RETRIEVE_SHEET = "üìà Recuperar Datos de Hoja de C√°lculo"
BUTTON_MENU2 = "Men√∫ 2"
BUTTON_VIEW_DATA = "üìä Ver Mis Datos"
BUTTON_DELETE_DATA = "üóëÔ∏è Eliminar Mis Datos"
BUTTON_EDIT_MESSAGES = "üìù Editar Mis Mensajes"
BUTTON_SUBITEM_1 = "{menu_id} Sub√≠tem 1"
BUTTON_SUBITEM_2 = "{menu_id} Sub√≠tem 2"
BUTTON_BACK_MAIN_MENU = "Volver al Men√∫ Principal"
BUTTON_CONFIRM_DELETE = "‚úÖ S√≠, Eliminar Mis Datos"
BUTTON_CANCEL_DELETE = "‚ùå No, Conservar Mis Datos"
CALLBACK_DATA_MENU1 = "menu1"
CALLBACK_DATA_RETRIEVE_FORM = "recuperar_formulario" # 'retrieve_form'
CALLBACK_DATA_RETRIEVE_SHEET = "recuperar_datos_hoja" # 'retrieve_sheet_data'
CALLBACK_DATA_MENU2 = "menu2"
CALLBACK_DATA_VIEW_DATA = "ver_mis_datos" # 'view_my_data'
CALLBACK_DATA_DELETE_DATA = "eliminar_mis_datos" # 'delete_my_data'
CALLBACK_DATA_SUBITEM_1 = "{menu_id}_sub1"
CALLBACK_DATA_SUBITEM_2 = "{menu_id}_sub2"
CALLBACK_DATA_MAIN_MENU = "menu_principal" # 'main_menu'
CALLBACK_DATA_CONFIRM_DELETE = "confirmar_eliminar" # 'confirm_delete'
CALLBACK_DATA_CANCEL_DELETE = "cancelar_eliminar" # 'cancel_delete'
USER_STATE_MAIN_MENU = 'menu_principal' # 'main_menu'
USER_STATE_DELETE_CONFIRMATION = 'confirmacion_eliminar' # 'delete_confirmation'
USER_STATE_MENU1 = 'menu1'
USER_STATE_MENU2 = 'menu2'

# --- Flask App ---
LOG_WEBHOOK_RECEIVED = "Actualizaci√≥n recibida v√≠a webhook: {json_preview}..."
ERROR_WEBHOOK_PROCESSING = "Error al procesar actualizaci√≥n de webhook: {error}"
LOG_WEBHOOK_SET = "Webhook configurado en {url}"
ERROR_WEBHOOK_SET = "Error al configurar webhook: {error}"
ERROR_WEBHOOK_INFO = "Error al obtener informaci√≥n del webhook: {error}"
ERROR_CHECK_UPDATES = "Error al comprobar actualizaciones manualmente: {error}"
ERROR_USER_NOT_FOUND = 'Usuario no encontrado'
ERROR_UPDATING_PREFERENCE = "Error al actualizar preferencia v√≠a ruta: {error}"
ERROR_MISSING_PREFERENCE_FIELDS = 'Faltan campos requeridos'
ERROR_INVALID_PREFERENCE_NAME = 'Nombre de preferencia inv√°lido. Debe ser uno de: {valid_prefs}'
PREFERENCE_UPDATE_SUCCESS = 'Preferencia {pref_name} actualizada'
LOG_SERVING_EDIT_MESSAGES_HTML = "Sirviendo edit_messages.html para solicitud de Aplicaci√≥n Web"
LOG_WEBAPP_GET_MESSAGES_REQUEST = "Solicitud recibida para /webapp/get_messages"
WARN_WEBAPP_MISSING_INIT_DATA = "Falta cabecera X-Telegram-Init-Data para {route}"
ERROR_WEBAPP_AUTH_REQUIRED = 'Autenticaci√≥n requerida'
ERROR_WEBAPP_INVALID_AUTH_DATA = 'Datos de autenticaci√≥n inv√°lidos'
LOG_WEBAPP_FETCHING_MESSAGES = "Obteniendo mensajes para user_id validado: {user_id}"
LOG_WEBAPP_FETCHED_MESSAGES = "{count} mensajes de texto obtenidos con √©xito para user_id: {user_id}"
ERROR_WEBAPP_FETCHING_MESSAGES = "Error al obtener mensajes para la aplicaci√≥n web: {error}"
ERROR_WEBAPP_INTERNAL_SERVER = 'Error interno del servidor'
LOG_WEBAPP_SAVE_MESSAGES_REQUEST = "Solicitud recibida para /webapp/save_messages"
LOG_WEBAPP_PROCESSING_SAVE = "Procesando solicitud save_messages para user_id validado: {user_id}"
WARN_WEBAPP_INVALID_SAVE_DATA = "Datos JSON inv√°lidos recibidos en save_messages para user_id: {user_id}"
ERROR_WEBAPP_INVALID_DATA_FORMAT = 'Formato de datos inv√°lido'
LOG_WEBAPP_SKIPPING_INVALID_ITEM = "Omitiendo √≠tem con formato inv√°lido en save_messages para usuario {user_id}: {item}"
ERROR_WEBAPP_INVALID_ITEM_FORMAT = "Formato de √≠tem inv√°lido: {item}"
WARN_WEBAPP_UPDATE_FAILED = "Fallo al actualizar mensaje db_id {db_id} para usuario {user_id}."
ERROR_WEBAPP_MESSAGE_NOT_FOUND = "ID de mensaje {db_id} no encontrado o no pertenece al usuario."
LOG_WEBAPP_FINISHED_SAVING = "Finalizado guardado de mensajes para user_id: {user_id}. √âxito: {success_count}, Fallo: {fail_count}"
ERROR_WEBAPP_DB_TRANSACTION = "Error de transacci√≥n BD al guardar mensajes para user_id {user_id}: {error}"
WEBAPP_SAVE_STATUS_SUCCESS = 'exito' # 'success'
WEBAPP_SAVE_STATUS_PARTIAL = 'error_parcial' # 'partial_error'
WEBAPP_SAVE_STATUS_ERROR = 'error'
WEBAPP_SAVE_MESSAGE_PARTIAL = 'Fallo al guardar {fail_count} mensaje(s).'
WEBAPP_SAVE_ERROR_TRANSACTION = "Transacci√≥n fallida: {error}"
HEALTH_CHECK_BOT_ERROR = "Error de bot en comprobaci√≥n de estado: {error}"
HEALTH_CHECK_DB_ERROR = "Error de BD en comprobaci√≥n de estado: {error}"

# --- Flask App Specific ---
VALIDATE_INIT_DATA_HASH_NOT_FOUND = "Hash no encontrado en initData"
VALIDATE_INIT_DATA_INVALID_HASH = "Hash inv√°lido"
VALIDATE_INIT_DATA_USER_ID_NOT_FOUND = "ID de usuario no encontrado en initData"
FLASK_WEBHOOK_SET_SUCCESS = '¬°Webhook configurado!'
FLASK_WEBHOOK_SET_ERROR = "Error al configurar webhook: {error}"

# --- Google API Specific ---
DEBUG_GEMINI_EXTRACT_ATTEMPT = "Intentando extraer texto de la respuesta de Gemini. Tipo: {type}, Contenido: {content_preview}..."
DEBUG_GEMINI_EXTRACT_FAIL_CONTENT = "Contenido problem√°tico de la respuesta de Gemini: {content}"
DEBUG_GEMINI_EXTRACT_FAIL_SNIPPET = "Fragmento de respuesta problem√°tico: {snippet}"
ERROR_FORM_API_UNKNOWN = "Error de API desconocido"
ERROR_FORM_API_STATUS_FALLBACK = "Error de API (Estado: {status_code})"

# --- Telegram Bot Specific ---
WELCOME_MESSAGE_DEFAULT = "Welcome to the bot! Choose an option:" # English default
WELCOME_MESSAGE_DEFAULT_ES = "¬°Bienvenido al bot! Elige una opci√≥n:" # Spanish version
ERROR_AI_NO_RESPONSE = "El servicio de IA no devolvi√≥ respuesta."
LOG_TRIGGER_GEMINI_ERROR = "Error en _trigger_gemini_analysis para el usuario {user_id}: {error}"
LOG_TRIGGER_GEMINI_RECOVERY_FAIL = "Fallo al enviar mensaje de error durante la recuperaci√≥n de _trigger_gemini_analysis: {nested_error}"
LOG_GEMINI_ANALYSIS_TRUNCATED = "Resultado largo del an√°lisis de Gemini truncado para el usuario {user_id}"
LOG_DATA_ENTRY_DETECTED = "Palabra clave de entrada de datos detectada. Guardando contenido: '{content_preview}...'"
CONFIRM_DATA_ENTRY_SAVED = "Entrada de datos guardada."
LOG_TRIGGER_GEMINI_TEXT_MSG = "Disparando an√°lisis de Gemini para mensaje de texto entrante del usuario {user_id}"
LOG_VIEW_DATA_UNEXPECTED_TYPE = "Tipo inesperado para message_text en view_my_data: {type}, valor: {value_repr}"

# --- Main Script ---
LOG_EFFECTIVE_UID = "UID efectivo: {uid}"
LOG_EFFECTIVE_USER = "Usuario efectivo: {user}"
WARN_CANNOT_GET_USER_INFO = "No se pudo obtener informaci√≥n del usuario: {error}"
FATAL_DB_INIT_FAILED = "FATAL: Fallo al inicializar la base de datos: {error}"
LOG_STARTING_DEBUG_POLLING = "Iniciando bot en modo DEBUG usando polling..."
LOG_REMOVING_WEBHOOK = "Intentando eliminar webhook existente (si lo hay)..."
LOG_WEBHOOK_REMOVED = "Webhook eliminado con √©xito (o no estaba configurado)."
WARN_CANNOT_REMOVE_WEBHOOK = "No se pudo eliminar el webhook (puede que no estuviera configurado): {error}"
LOG_POLLING_STARTED = "Polling del bot iniciado..."
ERROR_POLLING_FAILED = "Polling fall√≥: {error}"
LOG_POLLING_STOPPED = "Polling del bot detenido."
LOG_STARTING_PRODUCTION_WEBHOOK = "Iniciando bot en modo PRODUCCI√ìN usando webhook..."
FATAL_INVALID_BASE_URL_PRODUCTION = "FATAL: BASE_URL no est√° configurada, no es HTTPS, o es local en modo producci√≥n."
LOG_CURRENT_BASE_URL = "BASE_URL actual: {base_url}"
ERROR_REMOVING_WEBHOOK_PRODUCTION = "Error al eliminar webhook antes de configurar uno nuevo: {error}"
LOG_SETTING_WEBHOOK = "Configurando webhook en: {url}"
WARN_SSL_CERT_NOT_FOUND = "Certificado SSL o Clave no encontrados. Cert: {cert_path}, Key: {key_path}. Configurando webhook sin par√°metro de certificado."
LOG_WEBHOOK_SET_NO_CERT_PARAM = "Webhook configurado con √©xito (sin enviar par√°metro de certificado a Telegram)."
LOG_WEBHOOK_STATUS_CHECK = "Comprobaci√≥n de estado del webhook: URL='{url}', Actualizaciones pendientes={pending_updates}"
WARN_TELEGRAM_WEBHOOK_ERROR = "Telegram report√≥ error de webhook: {error_message}"
FATAL_WEBHOOK_SET_API_ERROR = "FATAL: Fallo al configurar webhook debido a error de API de Telegram: {error}"
FATAL_WEBHOOK_SET_OTHER_ERROR = "FATAL: Fallo al configurar webhook debido a otro error: {error}"
LOG_STARTING_FLASK = "Iniciando servidor Flask en 0.0.0.0:{port} con SSL..."
FATAL_SSL_FILES_NOT_FOUND_FLASK = "FATAL: Archivo de certificado o clave SSL no encontrado para el servidor Flask."
LOG_CERT_PATH_CHECKED = "Ruta de certificado comprobada: {path}"
LOG_KEY_PATH_CHECKED = "Ruta de clave comprobada: {path}"
FATAL_PORT_IN_USE = "FATAL: El puerto {port} ya est√° en uso."
FATAL_FLASK_OS_ERROR = "FATAL: Fallo al iniciar servidor Flask debido a error del SO: {error}"
FATAL_FLASK_START_FAILED = "FATAL: Fallo al iniciar servidor Flask: {error}"

# --- Test E2E Telethon ---
TEST_IMAGE_PATH = "images/cadorna.jpeg" # Path, no translation needed
TEST_IMAGE_CAPTION = "Imagen de prueba"
TEST_EXPECTED_NAME = "cadorna" # Keep as is, likely used for matching
TEST_EXPECTED_FIRST_NAME = "luigi" # Keep as is, likely used for matching
TEST_EXPECTED_TITLE = "general" # Keep as is, likely used for matching
TEST_TEXT_QUERY = "¬øC√≥mo se llama el paciente?" # Already in Spanish
TEST_IMAGE_VALIDATION_TEXT = "Informaci√≥n Extra√≠da" # "Extracted Information"
TEST_IMAGE_PROCESSING_TEXT = "Imagen de prueba" # "Processing your image"

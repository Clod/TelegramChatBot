# --- General ---
ERROR_GENERIC = "Ocurrió un error inesperado."
ERROR_PROCESSING_REQUEST = "Ocurrió un error al procesar tu solicitud."
ERROR_TRY_AGAIN_LATER = "Por favor, inténtalo de nuevo más tarde."
OPERATION_CANCELED = "Operación cancelada."
ACTION_NOT_RECOGNIZED = "Acción no reconocida."
BOT_IS_RUNNING = '¡El bot está funcionando!'

# --- Configuration Loading ---
LOG_DOTENV_LOADED = "Archivo .env cargado (override=True)"
LOG_RAW_DEBUG_MODE = "Cadena DEBUG_MODE cruda del entorno: '{raw_value}'"
LOG_DEBUG_MODE_EVALUATED = "DEBUG_MODE evaluado como: {debug_mode}"
DEBUG_MODE_ON = "¡Modo de depuración ACTIVADO!"
DEBUG_MODE_OFF = "¡Modo de depuración DESACTIVADO!"
ERROR_TOKEN_NOT_SET = "La variable de entorno TELEGRAM_BOT_TOKEN no está configurada"
WARN_BASE_URL_NOT_SET = "La variable de entorno BASE_URL no está configurada. Intentando inferir..."
WARN_INFERRED_BASE_URL = "BASE_URL inferida como {base_url}. Configúrala explícitamente en .env para producción."
WARN_GOOGLE_CREDS_NOT_SET = "La variable de entorno GOOGLE_APPLICATION_CREDENTIALS no está configurada o el archivo no existe. Algunas funciones de la API de Google podrían no funcionar."
WARN_GOOGLE_FORM_ID_NOT_SET = "No se pudo obtener GOOGLE_FORM_ID. La recuperación de formularios no funcionará."
LOG_GOOGLE_FORM_ID_SUCCESS = "GOOGLE_FORM_ID obtenido con éxito: {form_id}" # Corrected typo GOOLGE -> GOOGLE
WARN_APPS_SCRIPT_ID_NOT_SET = "La variable de entorno APPS_SCRIPT_ID no está configurada. La recuperación de Google Sheet no funcionará."
LOG_APPS_SCRIPT_ID_SUCCESS = "APPS_SCRIPT_ID obtenido con éxito: {script_id}"
WARN_APPS_SCRIPT_WEB_APP_NOT_SET = "Las variables de entorno APPS_SCRIPT_WEB_APP_URL o APPS_SCRIPT_API_KEY no están configuradas. La recuperación de Google Sheet a través de la Aplicación Web no funcionará."
LOG_APPS_SCRIPT_WEB_APP_SUCCESS = "APPS_SCRIPT_WEB_APP_URL obtenida con éxito."

# --- Database ---
LOG_DB_INIT_SUCCESS = "Base de datos inicializada con éxito"
LOG_DB_SAVED_MESSAGE = "Mensaje guardado del usuario {user_id}: {text_preview}..."
LOG_DB_SAVED_MEDIA_MESSAGE = "Mensaje {message_type} guardado del usuario {user_id}"
LOG_DB_SAVED_PROCESSED_TEXT = "Texto '{message_type}' guardado en user_messages para el usuario {user_id}, message_id original {original_message_id}"
ERROR_DB_SAVING_PROCESSED_TEXT = "Error al guardar el texto '{message_type}' en user_messages para el usuario {user_id}: {db_err}"
LOG_DB_DELETED_USER_DATA = "Datos de usuario eliminados para user_id {user_id}: {messages_deleted} mensajes, {interactions_deleted} interacciones"
ERROR_DB_DELETING_USER_DATA = "Error al eliminar datos de usuario: {error}"
LOG_DB_RETRIEVED_HISTORY = "Se recuperaron {count} mensajes para el usuario {user_id}, incluyendo datos procesados/recuperados"
LOG_DB_INITIATING_IMAGE_RESULT_STORAGE = "Iniciando almacenamiento en base de datos para respuesta de API Gemini para user_id: {user_id}, message_id: {message_id}"
LOG_DB_IMAGE_RESULT_STORED = "Respuesta de API Gemini almacenada con éxito en la base de datos (ID de registro: {record_id})"
ERROR_DB_SAVING_IMAGE_RESULT = "Error al guardar el resultado del procesamiento de imagen en la base de datos: {error}"
LOG_DB_SEARCHING_FORM_ID = "Buscando 'form=<ID>' en los últimos {search_limit} mensajes para el usuario {user_id}"
LOG_DB_FOUND_FORM_ID = "ID de respuesta encontrado: {response_id} en el mensaje: '{message_text}'"
WARN_DB_FORM_ID_NOT_FOUND = "No se pudo encontrar el patrón 'form=<ID>' para el usuario {user_id}"
ERROR_DB_RETRIEVING_USERS = "Error al recuperar usuarios de la BD: {error}"
ERROR_DB_RETRIEVING_IMAGE_RESULTS = "Error al recuperar resultados de procesamiento de imágenes de la BD: {error}"
ERROR_DB_RETRIEVING_MESSAGES = "Error al recuperar mensajes de usuario de la BD: {error}"
ERROR_DB_RETRIEVING_INTERACTIONS = "Error al recuperar interacciones de usuario de la BD: {error}"
ERROR_DB_UPDATING_PREFERENCE = "Fallo al actualizar la preferencia en la BD"
ERROR_DB_HEALTH_CHECK = "Error de BD en la comprobación de estado: {error}"
DB_STATUS_OK = 'ok'
DB_STATUS_MISSING = 'faltante' # 'missing'
DB_STATUS_ERROR = 'error'
DB_DEFAULT_LANGUAGE = 'es' # Changed default to Spanish
DB_DEFAULT_THEME = 'default' # 'default'
DB_ACTION_TYPE_TEXT = 'texto' # 'text'
DB_ACTION_TYPE_PROCESSED_IMAGE = 'texto_procesado_de_imagen' # 'processed_text_from_image'
DB_ACTION_TYPE_RETRIEVED_SHEET = 'datos_hoja_calculo_recuperados' # 'retrieved_sheet_data'
DB_ACTION_TYPE_RETRIEVED_FORM = 'datos_formulario_recuperados' # 'retrieved_form_data'
DB_MESSAGE_TYPE_TEXT = 'text'
DB_MESSAGE_TYPE_PHOTO = 'photo'
DB_MESSAGE_TYPE_PROCESSED_IMAGE = 'processed_text_from_image'
DB_MESSAGE_TYPE_RETRIEVED_FORM = 'retrieved_form_data'
DB_MESSAGE_TYPE_RETRIEVED_SHEET = 'retrieved_sheet_data'
DB_MESSAGE_TYPE_DATA_ENTRY = 'data_entry' # New type for 'dato[s]' messages

# --- Google APIs ---
LOG_GETTING_GEMINI_CREDS = "Intentando obtener credenciales para la API Gemini..."
ERROR_SERVICE_ACCOUNT_NOT_FOUND = "Archivo de cuenta de servicio no encontrado en la ruta: {path}"
LOG_TRYING_GEMINI_SCOPE = "Intentando credenciales Gemini con el scope: {scope}"
LOG_REFRESHING_GEMINI_CREDS = "Refrescando credenciales Gemini con el scope: {scope}"
LOG_GEMINI_TOKEN_SUCCESS = "Token de acceso Gemini obtenido con éxito, comienza con: {token_preview}"
WARN_GEMINI_NO_TOKEN = "No se obtuvo token con el scope: {scope}"
WARN_GEMINI_FAILED_TOKEN_SCOPE = "Fallo al obtener token con el scope {scope}: {error}"
ERROR_GEMINI_ALL_AUTH_FAILED = "Todos los intentos de autenticación de la API Gemini fallaron"
ERROR_GETTING_GEMINI_CREDS = "Error al obtener credenciales Gemini: {error}"
LOG_GETTING_GOOGLE_API_CREDS = "Intentando obtener credenciales para las APIs de Google..."
LOG_REQUESTING_GOOGLE_API_CREDS = "Solicitando credenciales de API de Google con scopes: {scopes}"
LOG_GOOGLE_API_CREDS_CREATED = "Objeto de credenciales de API de Google creado desde el archivo: {path}"
LOG_REFRESHING_GOOGLE_API_CREDS = "Intentando refrescar las credenciales de la API de Google..."
LOG_GOOGLE_API_CREDS_REFRESHED = "Credenciales de la API de Google refrescadas con éxito."
LOG_GOOGLE_API_TOKEN_SUCCESS = "Token de acceso de la API de Google obtenido, comienza con: {token_preview}"
LOG_GOOGLE_API_TOKEN_EXPIRY = "Hora de expiración del token: {expiry_time}"
LOG_GOOGLE_API_TOKEN_NO_EXPIRY = "Hora de expiración del token no disponible."
WARN_GOOGLE_API_NO_TOKEN = "Credenciales de API de Google refrescadas pero no se obtuvo token."
WARN_GOOGLE_API_REFRESH_FAILED = "Fallo al refrescar el token, pero continuando: {error}"
LOG_GOOGLE_API_CREDS_SUCCESS = "Credenciales obtenidas con éxito para las APIs de Google."
ERROR_GETTING_GOOGLE_API_CREDS = "Error al obtener credenciales de API de Google: {error}"
LOG_GEMINI_REQUEST_INITIATED = "Iniciando solicitud a la API Gemini para imagen del user_id: {user_id}"
ERROR_GEMINI_AUTH_FAILED = "Fallo al obtener credenciales autenticadas para Gemini"
ERROR_GEMINI_AUTH_FAILED_MSG = "Falló la autenticación."
ERROR_GEMINI_TOKEN_REFRESH_FAILED = "Fallo al obtener token de acceso después de refrescar para Gemini."
ERROR_GEMINI_TOKEN_REFRESH_FAILED_MSG = "Falló la actualización del token de autenticación."
LOG_GEMINI_SENDING_IMAGE = "Enviando datos de imagen al endpoint de la API Gemini: {endpoint}"
LOG_GEMINI_USING_TOKEN = "Usando token que comienza con: {token_preview} para procesamiento de imagen"
LOG_GEMINI_RAW_RESPONSE = "Respuesta cruda recibida de la API Gemini (Estado: {status_code}): {text_preview}..."
LOG_GEMINI_RESPONSE_SUCCESS = "Respuesta recibida con éxito de la API Gemini"
LOG_GEMINI_PARSED_SUCCESS = "Respuesta JSON parseada con éxito"
ERROR_GEMINI_REQUEST_FAILED = "Error de solicitud HTTP al llamar a la API Gemini: {error}"
ERROR_GEMINI_REQUEST_FAILED_USER_MSG = "Error de red al comunicarse con el servicio de IA ({status_code}): {error_text_preview}"
ERROR_GEMINI_JSON_DECODE = "Error al parsear la respuesta JSON de Gemini: {error}"
ERROR_GEMINI_JSON_DECODE_USER_MSG = "Se recibió un formato de datos inválido del servicio de IA."
ERROR_GEMINI_PROCESSING_IMAGE = "Error al procesar imagen con Gemini: {error}"
ERROR_GEMINI_PROCESSING_IMAGE_USER_MSG = "Ocurrió un error inesperado durante el procesamiento de IA."
ERROR_GEMINI_EXTRACT_UNEXPECTED_TYPE = "Tipo de respuesta inesperado para la extracción: {type}"
ERROR_GEMINI_EXTRACT_INVALID_FORMAT = "Error: Formato de respuesta inválido recibido."
WARN_GEMINI_RESPONSE_BLOCKED = "Respuesta de Gemini bloqueada. Razón: {reason}"
GEMINI_RESPONSE_BLOCKED_USER_MSG = "Contenido bloqueado por filtros de seguridad. Razón: {reason}. Detalles: {safety_ratings}"
WARN_GEMINI_NO_CANDIDATES = "No se encontraron candidatos ni razón de bloqueo en la respuesta de Gemini: {response}"
GEMINI_NO_TEXT_USER_MSG = "No se encontró contenido de texto en la respuesta de la IA."
WARN_GEMINI_NO_TEXT_EXTRACTED = "No se extrajo texto de las partes de la respuesta de Gemini."
LOG_GEMINI_EXTRACTED_PIPE_FORMAT = "El texto extraído parece estar en formato separado por pipes (|)."
WARN_GEMINI_EXTRACTED_UNEXPECTED_FORMAT = "El texto extraído podría no estar en el formato esperado separado por pipes: {text_preview}..."
ERROR_GEMINI_EXTRACTING_TEXT = "Error al extraer texto de la respuesta de Gemini: {error}"
ERROR_GEMINI_EXTRACTING_TEXT_USER_MSG = "Error al procesar el contenido de la respuesta de la IA."
LOG_GEMINI_TEXT_ANALYSIS_INITIATED = "Iniciando análisis de texto con Gemini para el usuario {user_id}"
ERROR_GEMINI_TEXT_AUTH_FAILED = "Fallo al obtener credenciales autenticadas para el análisis de texto de Gemini"
ERROR_GEMINI_TEXT_TOKEN_MISSING = "Credenciales obtenidas pero falta el token después de refrescar para el análisis de texto de Gemini."
ERROR_GEMINI_TEXT_TOKEN_MISSING_MSG = "Problema con el token de autenticación."
LOG_GEMINI_TEXT_USING_TOKEN = "Usando token que comienza con: {token_preview} para análisis de texto"
LOG_GEMINI_TEXT_SENDING_REQUEST = "Enviando solicitud de análisis de texto al endpoint de la API Gemini: {endpoint}"
LOG_GEMINI_TEXT_ANALYSIS_SUCCESS = "Análisis de Gemini recibido y extraído con éxito para el usuario {user_id}"
ERROR_GEMINI_TEXT_REQUEST_FAILED = "Error de solicitud HTTP al llamar a la API Gemini para análisis de texto: {error}"
ERROR_GEMINI_TEXT_JSON_DECODE = "Error al parsear la respuesta JSON de Gemini para análisis de texto: {error}"
ERROR_GEMINI_TEXT_PROCESSING = "Error al procesar texto con Gemini para el usuario {user_id}: {error}"
ERROR_GEMINI_TEXT_PROCESSING_USER_MSG = "Ocurrió un error inesperado durante el análisis de texto de IA."
LOG_FORM_RETRIEVAL_INITIATED = "Intentando recuperar la respuesta {response_id} del formulario {form_id}"
ERROR_FORM_AUTH_FAILED = "Fallo al obtener credenciales para la API de Google Forms."
ERROR_FORM_AUTH_FAILED_MSG = "Falló la autenticación."
LOG_FORM_RETRIEVAL_SUCCESS = "Respuesta de formulario {response_id} recuperada con éxito"
ERROR_FORM_API = "Error de la API de Google Forms: {status_code} - {error_message}"
ERROR_FORM_API_USER_MSG = "Error de API ({status_code}): {error_message}"
ERROR_FORM_NOT_FOUND_USER_MSG = "ID de respuesta '{response_id}' no encontrado en el formulario '{form_id}'."
ERROR_FORM_PERMISSION_DENIED_USER_MSG = "Permiso denegado. Asegúrate de que la cuenta de servicio tenga acceso a las respuestas del formulario."
ERROR_FORM_UNEXPECTED = "Error inesperado al recuperar la respuesta del formulario: {error}"
LOG_APPS_SCRIPT_CALL_INITIATED = "Iniciando llamada a Apps Script ID: {script_id}, Función: {function_name}"
LOG_APPS_SCRIPT_PARAMETERS = "Parámetros de Apps Script: {parameters}"
ERROR_APPS_SCRIPT_AUTH_FAILED = "Fallo al obtener credenciales para la llamada a Apps Script."
ERROR_APPS_SCRIPT_AUTH_FAILED_MSG = "Falló la autenticación. No se pudieron obtener las credenciales."
LOG_APPS_SCRIPT_USING_CREDS = "Usando credenciales para la cuenta de servicio: {email}"
LOG_APPS_SCRIPT_CREDS_DETAILS = "Credenciales válidas: {valid}, Scopes: {scopes}"
LOG_APPS_SCRIPT_BUILDING_SERVICE = "Construyendo servicio de API de Apps Script (script, v1)..."
LOG_APPS_SCRIPT_SERVICE_BUILT = "Servicio de API de Apps Script construido con éxito."
LOG_APPS_SCRIPT_EXECUTING = "Ejecutando función de Apps Script '{function_name}'..."
LOG_APPS_SCRIPT_REQUEST_BODY = "Cuerpo de la solicitud de Apps Script: {request}"
LOG_APPS_SCRIPT_RESPONSE_RECEIVED = "Respuesta recibida de la ejecución de Apps Script."
LOG_APPS_SCRIPT_RAW_RESPONSE = "Respuesta cruda de Apps Script: {response}"
ERROR_APPS_SCRIPT_EXECUTION = "Error de ejecución de Apps Script: Tipo={error_type}, Mensaje={error_message}"
LOG_APPS_SCRIPT_STACKTRACE = "Stacktrace de Apps Script: {stacktrace}"
ERROR_APPS_SCRIPT_EXECUTION_USER_MSG = "Error durante la ejecución del script: {error_message}"
ERROR_APPS_SCRIPT_AUTH_REQUIRED_USER_MSG = "Error de autorización dentro de Apps Script."
ERROR_APPS_SCRIPT_NOT_FOUND_USER_MSG = "Error dentro de Apps Script: '{function_name}' o código relacionado no encontrado."
LOG_APPS_SCRIPT_EXECUTION_SUCCESS = "Ejecución de Apps Script exitosa. Tipo de resultado: {type}"
LOG_APPS_SCRIPT_RESULT = "Resultado de Apps Script: {result}"
ERROR_APPS_SCRIPT_HTTP = "Error HTTP al llamar a la API de Apps Script: Estado={status_code}, Respuesta={error_content}"
ERROR_APPS_SCRIPT_HTTP_USER_MSG = "Ocurrió un error de API ({status_code}). Revisa los logs para detalles."
ERROR_APPS_SCRIPT_HTTP_401_USER_MSG = "Falló la autenticación (401)."
ERROR_APPS_SCRIPT_HTTP_403_USER_MSG = "Permiso denegado (403). Asegúrate de que la API de Apps Script esté habilitada y la cuenta de servicio tenga permiso."
ERROR_APPS_SCRIPT_HTTP_404_USER_MSG = "Proyecto de Apps Script (ID: {script_id}) no encontrado (404)."
ERROR_APPS_SCRIPT_HTTP_429_USER_MSG = "Límite de tasa de API excedido (429)."
ERROR_APPS_SCRIPT_UNEXPECTED = "Error inesperado al llamar a Apps Script: {error}"
ERROR_APPS_SCRIPT_UNEXPECTED_USER_MSG = "Ocurrió un error inesperado al comunicarse con el servicio de Apps Script."
LOG_WEB_APP_CALL_INITIATED = "Iniciando llamada a la Aplicación Web de Apps Script para el ID: {id_to_find}"
ERROR_WEB_APP_NOT_CONFIGURED = "La URL de la Aplicación Web o la Clave API no están configuradas."
ERROR_WEB_APP_NOT_CONFIGURED_USER_MSG = "La recuperación mediante Aplicación Web no está configurada en el servidor."
LOG_WEB_APP_MAKING_REQUEST = "Realizando solicitud GET a la URL de la Aplicación Web (parámetros omitidos por seguridad)"
LOG_WEB_APP_ATTEMPTING_GET = "Intentando requests.get a {target_url} con timeout=30..."
LOG_WEB_APP_GET_COMPLETED = "Llamada requests.get completada. Código de estado recibido: {status_code}"
LOG_WEB_APP_RESPONSE_RECEIVED = "Respuesta recibida de la Aplicación Web. Estado: {status_code}, Content-Type: {content_type}"
LOG_WEB_APP_RAW_RESPONSE = "Texto de respuesta crudo (primeros 500 caracteres): {text_preview}"
WARN_WEB_APP_NOT_FOUND = "La Aplicación Web devolvió 'No Encontrado' para el ID: {id_to_find}"
WEB_APP_NOT_FOUND_USER_MSG = "ID '{id_to_find}' no encontrado en la Google Sheet."
ERROR_WEB_APP_UNAUTHORIZED = "La Aplicación Web devolvió 'No Autorizado'. Verifica la Clave API."
WEB_APP_UNAUTHORIZED_USER_MSG = "Autorización fallida. Clave API inválida proporcionada a la Aplicación Web."
ERROR_WEB_APP_BAD_REQUEST = "La Aplicación Web devolvió 'Solicitud Incorrecta'. Verifica si el parámetro 'id' falta o es inválido."
WEB_APP_BAD_REQUEST_USER_MSG = "Solicitud incorrecta enviada a la Aplicación Web (ej., ID faltante)."
LOG_WEB_APP_JSON_PARSED = "Respuesta JSON de la Aplicación Web parseada con éxito para el ID: {id_to_find}"
ERROR_WEB_APP_JSON_DECODE = "Fallo al decodificar la respuesta JSON de la Aplicación Web: {error}"
ERROR_WEB_APP_JSON_DECODE_TEXT = "El texto de la respuesta fue: {text}"
WEB_APP_INVALID_DATA_USER_MSG = "Se recibió un formato de datos inválido de la Aplicación Web."
ERROR_WEB_APP_TIMEOUT = "La solicitud a la Aplicación Web expiró para el ID: {id_to_find}"
WEB_APP_TIMEOUT_USER_MSG = "La solicitud a la Aplicación Web expiró (timeout)."
ERROR_WEB_APP_REQUEST_FAILED = "Error de solicitud HTTP al llamar a la Aplicación Web: {error}"
WEB_APP_REQUEST_FAILED_USER_MSG = "Error de red al comunicarse con la Aplicación Web: {error}"
WEB_APP_REQUEST_FAILED_401_USER_MSG = "Acceso denegado a la Aplicación Web (401). Verifica permisos/despliegue del script."
WEB_APP_REQUEST_FAILED_403_USER_MSG = "Aplicación Web prohibida (403). Verifica la clave API o el acceso del script."
WEB_APP_REQUEST_FAILED_404_USER_MSG = "URL de la Aplicación Web no encontrada (404)."
WEB_APP_REQUEST_FAILED_500_USER_MSG = "Error dentro del script de la Aplicación Web (500)."
ERROR_WEB_APP_UNEXPECTED = "Error inesperado al recuperar datos vía Aplicación Web: {error}"
WEB_APP_UNEXPECTED_USER_MSG = "Ocurrió un error inesperado al contactar la Aplicación Web."
GEMINI_PROMPT_IMAGE_ANALYSIS = "Analiza la imagen y extrae la siguiente información personal: nombre completo, fecha de nacimiento, edad, correo electrónico, número de teléfono, ciudad, estado/provincia, género y método de contacto preferido. Devuelve la información extraída como una **única cadena de texto** con **pares clave-valor separados por el símbolo de pipe (|)**. El formato debe ser: `clave=valor|clave=valor|clave=valor|...`. Usa las siguientes claves: `full_name`, `date_of_birth`, `age`, `email`, `phone_number`, `city`, `state`, `gender`, y `preferred_contact_method`. Por ejemplo: `full_name=LUIGI CADORNA|date_of_birth=8/2/1962|age=63|email=luigi.cadorna@ymail.com|phone_number=1234567890|city=Buenos Aires|state=JALISCO|gender=Male|preferred_contact_method=Mail` Si alguna pieza de información no puede ser extraída con confianza de la imagen, deja el valor correspondiente **vacío** (para cadenas de texto) o `null` (para números como la edad), pero incluye igualmente la clave en la cadena de salida. Por ejemplo, si no se encuentra el correo electrónico, debería ser `email=|...` y si no se encuentra la edad, debería ser `age=null|...`. Asegúrate de que la respuesta sea **únicamente la cadena de texto** con los pares clave-valor separados por pipes, sin ningún formato markdown, bloques de código o texto adicional."
GEMINI_PROMPT_TEXT_ANALYSIS = "Analiza los siguientes mensajes de usuario y comprueba si hay preguntas o instrucciones sobre lo que debes hacer. Tu respuesta debe incluir la(s) respuesta(s) a todas las preguntas e instrucciones. Mantén tu respuesta concisa y amigable y SIEMPRE en español:\n\n"
API_SCOPE_CLOUD_PLATFORM = "https://www.googleapis.com/auth/cloud-platform"
API_SCOPE_AI_PLATFORM = "https://www.googleapis.com/auth/aiplatform"
API_SCOPE_GENERATIVE_AI = "https://www.googleapis.com/auth/generative-ai"
API_SCOPE_FORMS_READONLY = "https://www.googleapis.com/auth/forms.responses.readonly"
API_SCOPE_SCRIPT_EXECUTE = "https://www.googleapis.com/auth/script.execute"

# --- Utils ---
LOG_CLEANUP_SKIPPED_NO_PATH = "Limpieza omitida: No se proporcionó ruta de archivo."
LOG_CLEANUP_INITIATED = "Iniciando limpieza de archivo temporal: {path}"
LOG_CLEANUP_SUCCESS = "Archivo temporal eliminado con éxito: {path}"
WARN_CLEANUP_NOT_FOUND = "Limpieza omitida: Archivo no encontrado en {path}"
ERROR_CLEANUP_FAILED = "Error al limpiar archivo temporal {path}: {error}"

# --- Telegram Bot ---
LOG_MENU_GENERATION_DEBUG = "generate_main_menu: DEBUG_MODE={debug_mode}, BASE_URL='{base_url}'"
LOG_MENU_GENERATION_ADDING_WEBAPPS = "generate_main_menu: Se cumplen las condiciones para añadir botones de Aplicación Web."
LOG_MENU_GENERATION_CHECKING_URL = "Comprobando URL de Mensajes: {url}"
LOG_MENU_GENERATION_ADDING_BUTTON = "generate_main_menu: Añadiendo botón '{button_text}'."
LOG_MENU_GENERATION_ADDING_WEBAPP_BUTTONS = "generate_main_menu: Llamando a markup.add() con {count} botón(es) de aplicación web."
WARN_MENU_GENERATION_NO_WEBAPP_BUTTONS = "generate_main_menu: No se crearon botones válidos de Aplicación Web, omitiendo markup.add()."
WARN_MENU_GENERATION_NO_HTTPS = "generate_main_menu: BASE_URL no está configurada o no usa HTTPS. Los botones de Aplicación Web no se mostrarán."
LOG_MENU_GENERATION_DEBUG_SKIPPING_WEBAPPS = "generate_main_menu: DEBUG_MODE es True, omitiendo botones de Aplicación Web."
LOG_SENT_MAIN_MENU = "Menú principal enviado como nuevo mensaje al chat {chat_id}"
ERROR_SENDING_MAIN_MENU = "Fallo al enviar mensaje de menú principal al chat {chat_id}: {error}"
LOG_IMAGE_DOWNLOAD_START = "Iniciando proceso de descarga de imagen para file_id: {file_id}, user_id: {user_id}, message_id: {message_id}"
LOG_IMAGE_DOWNLOAD_SUCCESS = "Imagen descargada con éxito a {path} (Tamaño: {size} bytes)"
ERROR_IMAGE_DOWNLOAD = "Error al descargar imagen: {error}"
LOG_SENT_GENERATED_FILE = "Archivo generado {filename} enviado al chat {chat_id}"
ERROR_GENERATING_FILE = "Error al generar/enviar archivo para el chat {chat_id}: {error}"
ERROR_GENERATING_FILE_USER_MSG = "Lo siento, no pude generar o enviar el archivo."
LOG_RECEIVED_COMMAND = "Comando /{command} recibido del usuario {user_id} en el chat {chat_id}"
LOG_SENT_WELCOME_MENU = "Mensaje de bienvenida con menú principal enviado al usuario {user_id}"
ERROR_START_HELP_FAILED = "Error durante handle_start_help para el usuario {user_id}: {error}"
ERROR_START_HELP_USER_MSG = "Lo siento, algo salió mal. Por favor, intenta /start de nuevo más tarde."
ERROR_SENDING_ERROR_MSG = "Fallo al enviar mensaje de error al usuario {user_id}: {error}"
LOG_RECEIVED_PHOTO = "Foto recibida del usuario {user_id} en el chat {chat_id}, message_id {message_id}"
PHOTO_NO_DATA_USER_MSG = "No pude encontrar datos de imagen en tu mensaje."
LOG_PHOTO_NO_DATA = 'mensaje_foto_sin_datos' # 'photo_message_no_data'
LOG_IMAGE_RECEIVED_DETAILS = "Imagen recibida del usuario {user_id}, ID de mensaje {message_id}. File ID: {file_id}"
PHOTO_PROCESSING_USER_MSG = "Procesando tu imagen..."
PHOTO_DOWNLOAD_FAILED_USER_MSG = "Lo siento, no pude descargar tu imagen."
LOG_DOWNLOAD_IMAGE_ERROR = 'error_descarga_imagen' # 'download_image_error'
LOG_IMAGE_PROCESSING_WORKFLOW_START = "Iniciando flujo de trabajo de procesamiento de imagen para el usuario {user_id}"
PHOTO_PROCESSING_FAILED_USER_MSG = "Lo siento, no pude procesar tu imagen. Error: {error_text}"
LOG_GEMINI_PROCESSING_ERROR = 'error_procesamiento_gemini' # 'gemini_processing_error'
LOG_EXTRACTED_TEXT_PREVIEW = "Texto extraído de Gemini para el usuario {user_id}: {text_preview}..."
LOG_CONVERTED_TO_JSON = "Texto extraído convertido a JSON con éxito para el usuario {user_id}"
WARN_CONVERSION_INVALID_PAIR = "Omitiendo par inválido '{pair}' en la respuesta de Gemini para el usuario {user_id}"
WARN_CONVERSION_NO_PAIRS = "No se pudieron parsear pares clave-valor válidos de la respuesta de Gemini para el usuario {user_id}. Guardando texto original."
WARN_CONVERSION_NOT_PIPE_SEPARATED = "Texto extraído para el usuario {user_id} no está separado por pipes. Guardando texto original."
ERROR_CONVERTING_TO_JSON = "Error al convertir cadena separada por pipes a JSON para el usuario {user_id}: {error}"
WARN_FAILED_SAVING_IMAGE_RESULT = "Fallo al guardar resultado de procesamiento de imagen en BD para el usuario {user_id}"
PHOTO_EXTRACTED_INFO_USER_MSG = "Información Extraída:\n\n{result_text}"
WARN_TRUNCATED_MESSAGE = "Mensaje de texto extraído largo truncado para el usuario {user_id}"
LOG_SENT_EXTRACTED_TEXT = 'texto_extraido_enviado' # 'sent_extracted_text'
LOG_IMAGE_PROCESSING_WORKFLOW_SUCCESS = "Flujo de trabajo de procesamiento de imagen completado con éxito para el usuario {user_id}"
PHOTO_PROCESSED_NEXT_ACTION_USER_MSG = "Imagen procesada. ¿Qué te gustaría hacer ahora?"
ERROR_IMAGE_WORKFLOW = "Error en el flujo de trabajo de procesamiento de imagen: {error}"
PHOTO_ERROR_USER_MSG = "Lo siento, ocurrió un error mientras procesaba tu imagen."
LOG_PHOTO_WORKFLOW_ERROR = 'error_flujo_trabajo_foto' # 'photo_workflow_error'
LOG_IMAGE_WORKFLOW_CLEANUP_COMPLETE = "Limpieza del flujo de trabajo de procesamiento de imagen completada para el usuario {user_id}"
TEXT_UNKNOWN_COMMAND_USER_MSG = "Lo siento, no entiendo ese comando."
LOG_SKIPPED_MENU_FOR_COMMAND = "Se omitió el envío del menú principal desde handle_text para el comando '{command}' en el chat {chat_id}"
TEXT_HISTORY_HEADER = "📝 Tu historial de mensajes:\n\n"
TEXT_HISTORY_NO_PREVIOUS = "No se encontraron mensajes anteriores."
TEXT_RECEIVED_USER_MSG = "Recibí tu mensaje."
TEXT_RECEIVED_NO_HISTORY_USER_MSG = "Recibí tu mensaje. No se encontró historial."
LOG_SENT_MENU_AFTER_TEXT = "Menú principal enviado después de manejar texto no-comando del chat {chat_id}"
LOG_BUTTON_CLICK = "clic_boton" # 'button_click'
LOG_USER_ACTION = "Usuario {user_id}: {action}"
LOG_CALLBACK_RETRIEVE_FORM = "Usuario {user_id}: Hizo clic en 'Recuperar Datos de Formulario'"
CALLBACK_FORM_NOT_CONFIGURED = "La recuperación de formularios no está configurada."
CALLBACK_SEARCHING_FORM_ID = "Buscando ID de respuesta de formulario..."
CALLBACK_FORM_ID_NOT_FOUND = "No se pudo encontrar 'form=<número>' en el historial reciente."
CALLBACK_FOUND_FORM_ID = "ID encontrado: {response_id}. Recuperando datos..."
CALLBACK_FORM_DATA_DISPLAY = "📄 Datos de Respuesta de Formulario (ID: {response_id}):\n\n```json\n{json_string}\n```"
CALLBACK_FORM_DATA_TRUNCATED = "... (truncado)\n```"
ERROR_DISPLAYING_FORM_DATA = "Error al formatear/mostrar datos del formulario: {error}"
CALLBACK_FORM_DISPLAY_ERROR_USER_MSG = "Datos recuperados para {response_id}, pero falló al mostrarlos."
CALLBACK_FORM_RETRIEVAL_FAILED_USER_MSG = "❌ Fallo al recuperar datos del formulario:\n{error_message}"
LOG_FORM_RETRIEVAL_SUCCESS = "exito_recuperacion_formulario" # 'form_retrieval_success'
LOG_FORM_RETRIEVAL_FAILED = "fallo_recuperacion_formulario" # 'form_retrieval_failed'
LOG_CALLBACK_RETRIEVE_SHEET = "Usuario {user_id}: Hizo clic en 'Recuperar Datos de Hoja de Cálculo'"
CALLBACK_SHEET_NOT_CONFIGURED = "La recuperación de hoja de cálculo vía Aplicación Web no está configurada."
CALLBACK_SEARCHING_SHEET_ID = "Buscando ID (form=<número>)..."
LOG_CALLING_WEB_APP = "Llamando a get_sheet_data_via_webapp para el ID: {id_to_find}"
CALLBACK_SHEET_DATA_DISPLAY = "📈 Datos de Hoja de Cálculo (ID: {id_to_find}):\n\n```json\n{json_string}\n```"
ERROR_DISPLAYING_SHEET_DATA = "Error al formatear/mostrar datos de la hoja de cálculo: {error}"
CALLBACK_SHEET_DISPLAY_ERROR_USER_MSG = "Datos de hoja de cálculo recuperados para {id_to_find}, pero falló al mostrarlos."
CALLBACK_SHEET_RETRIEVAL_FAILED_USER_MSG = "❌ Fallo al recuperar datos de la hoja de cálculo:\n{error_message}"
LOG_SHEET_RETRIEVAL_SUCCESS = "exito_recuperacion_hoja" # 'sheet_retrieval_success'
LOG_SHEET_RETRIEVAL_FAILED = "fallo_recuperacion_hoja" # 'sheet_retrieval_failed'
LOG_CALLBACK_VIEW_DATA = "Usuario {user_id}: Solicitó ver sus datos"
CALLBACK_DATA_SUMMARY_HEADER = "📊 Resumen de Tus Datos\n\nPerfil:\n"
CALLBACK_DATA_SUMMARY_PROFILE = "• Usuario: @{username}\n• Nombre: {first_name} {last_name}\n• Se unió: {created_at}\n\nPreferencias:\n"
CALLBACK_DATA_SUMMARY_PREFS = "• Idioma: {language}\n\nActividad:\n"
CALLBACK_DATA_SUMMARY_ACTIVITY = "• Mensajes: {message_count}\n• Interacciones: {interaction_count}\n\nMensajes Recientes:\n"
CALLBACK_DATA_SUMMARY_RECENT_MSG = "{index}. {text_preview}{ellipsis}\n"
CALLBACK_DATA_SUMMARY_NO_RECENT = "Ninguno\n"
CALLBACK_DATA_SUMMARY_NO_TEXT = "[Sin Texto/Media]" # Placeholder for None message text
CALLBACK_NO_DATA_FOUND = "No se encontraron datos."
LOG_CALLBACK_DELETE_DATA = "Usuario {user_id}: Solicitó eliminación de datos"
CALLBACK_DELETE_CONFIRMATION_USER_MSG = "⚠️ ¿Seguro que quieres eliminar todos tus datos? No se puede deshacer."
LOG_CALLBACK_CONFIRM_DELETE = "Usuario {user_id}: Confirmó eliminación de datos"
CALLBACK_DELETE_SUCCESS_USER_MSG = "✅ Datos eliminados ({msg_del} msgs, {int_del} interacciones). Usa /start de nuevo."
CALLBACK_DELETE_SUCCESS_NEXT_ACTION = "Datos eliminados. Elige una opción:"
CALLBACK_DELETE_ERROR_USER_MSG = "❌ Error al eliminar datos."
LOG_CALLBACK_CANCEL_DELETE = "Usuario {user_id}: Canceló eliminación de datos"
LOG_CALLBACK_MENU1 = "Usuario {user_id}: Menú 1 (Analizar Mensajes) seleccionado"
CALLBACK_ANALYZING_MESSAGES = "Analizando mensajes..."
CALLBACK_NO_MESSAGES_TO_ANALYZE = "No hay mensajes para analizar."
CALLBACK_ANALYSIS_PROMPT_JSON = "- Datos JSON: {formatted_json}\n"
CALLBACK_ANALYSIS_PROMPT_TEXT = "- {text}\n"
LOG_SENDING_PROMPT_TO_GEMINI = "Enviando prompt a Gemini para análisis (usuario {user_id}): {prompt_preview}..."
CALLBACK_ANALYSIS_ERROR_USER_MSG = "Lo siento, no pude analizar los mensajes. Error: {error_text}"
CALLBACK_ANALYSIS_RESULT_USER_MSG = "📊 Análisis:\n\n{analysis_result}"
LOG_CALLBACK_MENU2 = "Usuario {user_id}: Menú 2 seleccionado"
CALLBACK_MENU2_USER_MSG = "Menú 2 seleccionado. Elige subítem:"
LOG_CALLBACK_MAIN_MENU = "Usuario {user_id}: Volvió al menú principal"
CALLBACK_MAIN_MENU_USER_MSG = "Menú Principal:"
LOG_CALLBACK_SUBMENU = "Usuario {user_id}: Procesando {callback_data}"
CALLBACK_PROCESSING_SUBMENU = "Procesando {callback_data}..."
CALLBACK_SUBMENU_PROCESSED_NEXT_ACTION = "{callback_data} procesado. Elige la siguiente opción:"
CALLBACK_SUBMENU_ACTION_PROCESSED = "Acción '{callback_data}' procesada."
WARN_UNHANDLED_CALLBACK = "Callback no manejado del usuario {user_id}: {callback_data}"
WARN_EDIT_MESSAGE_NOT_FOUND = "No se pudo editar el mensaje {message_id} para el chat {chat_id}. Podría haber sido eliminado o ser muy antiguo. Enviando nuevo mensaje en su lugar."
CALLBACK_DEFAULT_USER_MSG = "Por favor, elige una opción:"
ERROR_CALLBACK_API = "Error de API de Telegram manejando callback '{callback_data}' para usuario {user_id}: {api_ex}"
ERROR_CALLBACK_API_USER_MSG = "Lo siento, ocurrió un error de Telegram."
ERROR_CALLBACK_GENERAL = "Error manejando consulta de callback '{callback_data}' para usuario {user_id}: {error}"
ERROR_CALLBACK_GENERAL_USER_MSG = "Ocurrió un error procesando tu solicitud."
ERROR_CALLBACK_GENERAL_EDIT_MSG = "Ocurrió un error. Por favor, inténtalo de nuevo."
ERROR_SENDING_CALLBACK_FEEDBACK = "Fallo al enviar feedback de error para callback '{callback_data}' al usuario {user_id}: {nested_error}"
BUTTON_ANALYZE_MESSAGES = "📊 Analizar Mis Mensajes"
BUTTON_RETRIEVE_FORM = "📄 Recuperar Datos de Formulario"
BUTTON_RETRIEVE_SHEET = "📈 Recuperar Datos de Hoja de Cálculo"
BUTTON_MENU2 = "Menú 2"
BUTTON_VIEW_DATA = "📊 Ver Mis Datos"
BUTTON_DELETE_DATA = "🗑️ Eliminar Mis Datos"
BUTTON_EDIT_MESSAGES = "📝 Editar Mis Mensajes"
BUTTON_SUBITEM_1 = "{menu_id} Subítem 1"
BUTTON_SUBITEM_2 = "{menu_id} Subítem 2"
BUTTON_BACK_MAIN_MENU = "Volver al Menú Principal"
BUTTON_CONFIRM_DELETE = "✅ Sí, Eliminar Mis Datos"
BUTTON_CANCEL_DELETE = "❌ No, Conservar Mis Datos"
CALLBACK_DATA_MENU1 = "menu1"
CALLBACK_DATA_RETRIEVE_FORM = "recuperar_formulario" # 'retrieve_form'
CALLBACK_DATA_RETRIEVE_SHEET = "recuperar_datos_hoja" # 'retrieve_sheet_data'
CALLBACK_DATA_MENU2 = "menu2"
CALLBACK_DATA_VIEW_DATA = "ver_mis_datos" # 'view_my_data'
CALLBACK_DATA_DELETE_DATA = "eliminar_mis_datos" # 'delete_my_data'
CALLBACK_DATA_SUBITEM_1 = "{menu_id}_sub1"
CALLBACK_DATA_SUBITEM_2 = "{menu_id}_sub2"
CALLBACK_DATA_MAIN_MENU = "menu_principal" # 'main_menu'
CALLBACK_DATA_CONFIRM_DELETE = "confirmar_eliminar" # 'confirm_delete'
CALLBACK_DATA_CANCEL_DELETE = "cancelar_eliminar" # 'cancel_delete'
USER_STATE_MAIN_MENU = 'menu_principal' # 'main_menu'
USER_STATE_DELETE_CONFIRMATION = 'confirmacion_eliminar' # 'delete_confirmation'
USER_STATE_MENU1 = 'menu1'
USER_STATE_MENU2 = 'menu2'

# --- Flask App ---
LOG_WEBHOOK_RECEIVED = "Actualización recibida vía webhook: {json_preview}..."
ERROR_WEBHOOK_PROCESSING = "Error al procesar actualización de webhook: {error}"
LOG_WEBHOOK_SET = "Webhook configurado en {url}"
ERROR_WEBHOOK_SET = "Error al configurar webhook: {error}"
ERROR_WEBHOOK_INFO = "Error al obtener información del webhook: {error}"
ERROR_CHECK_UPDATES = "Error al comprobar actualizaciones manualmente: {error}"
ERROR_USER_NOT_FOUND = 'Usuario no encontrado'
ERROR_UPDATING_PREFERENCE = "Error al actualizar preferencia vía ruta: {error}"
ERROR_MISSING_PREFERENCE_FIELDS = 'Faltan campos requeridos'
ERROR_INVALID_PREFERENCE_NAME = 'Nombre de preferencia inválido. Debe ser uno de: {valid_prefs}'
PREFERENCE_UPDATE_SUCCESS = 'Preferencia {pref_name} actualizada'
LOG_SERVING_EDIT_MESSAGES_HTML = "Sirviendo edit_messages.html para solicitud de Aplicación Web"
LOG_WEBAPP_GET_MESSAGES_REQUEST = "Solicitud recibida para /webapp/get_messages"
WARN_WEBAPP_MISSING_INIT_DATA = "Falta cabecera X-Telegram-Init-Data para {route}"
ERROR_WEBAPP_AUTH_REQUIRED = 'Autenticación requerida'
ERROR_WEBAPP_INVALID_AUTH_DATA = 'Datos de autenticación inválidos'
LOG_WEBAPP_FETCHING_MESSAGES = "Obteniendo mensajes para user_id validado: {user_id}"
LOG_WEBAPP_FETCHED_MESSAGES = "{count} mensajes de texto obtenidos con éxito para user_id: {user_id}"
ERROR_WEBAPP_FETCHING_MESSAGES = "Error al obtener mensajes para la aplicación web: {error}"
ERROR_WEBAPP_INTERNAL_SERVER = 'Error interno del servidor'
LOG_WEBAPP_SAVE_MESSAGES_REQUEST = "Solicitud recibida para /webapp/save_messages"
LOG_WEBAPP_PROCESSING_SAVE = "Procesando solicitud save_messages para user_id validado: {user_id}"
WARN_WEBAPP_INVALID_SAVE_DATA = "Datos JSON inválidos recibidos en save_messages para user_id: {user_id}"
ERROR_WEBAPP_INVALID_DATA_FORMAT = 'Formato de datos inválido'
LOG_WEBAPP_SKIPPING_INVALID_ITEM = "Omitiendo ítem con formato inválido en save_messages para usuario {user_id}: {item}"
ERROR_WEBAPP_INVALID_ITEM_FORMAT = "Formato de ítem inválido: {item}"
WARN_WEBAPP_UPDATE_FAILED = "Fallo al actualizar mensaje db_id {db_id} para usuario {user_id}."
ERROR_WEBAPP_MESSAGE_NOT_FOUND = "ID de mensaje {db_id} no encontrado o no pertenece al usuario."
LOG_WEBAPP_FINISHED_SAVING = "Finalizado guardado de mensajes para user_id: {user_id}. Éxito: {success_count}, Fallo: {fail_count}"
ERROR_WEBAPP_DB_TRANSACTION = "Error de transacción BD al guardar mensajes para user_id {user_id}: {error}"
WEBAPP_SAVE_STATUS_SUCCESS = 'exito' # 'success'
WEBAPP_SAVE_STATUS_PARTIAL = 'error_parcial' # 'partial_error'
WEBAPP_SAVE_STATUS_ERROR = 'error'
WEBAPP_SAVE_MESSAGE_PARTIAL = 'Fallo al guardar {fail_count} mensaje(s).'
WEBAPP_SAVE_ERROR_TRANSACTION = "Transacción fallida: {error}"
HEALTH_CHECK_BOT_ERROR = "Error de bot en comprobación de estado: {error}"
HEALTH_CHECK_DB_ERROR = "Error de BD en comprobación de estado: {error}"

# --- Flask App Specific ---
VALIDATE_INIT_DATA_HASH_NOT_FOUND = "Hash no encontrado en initData"
VALIDATE_INIT_DATA_INVALID_HASH = "Hash inválido"
VALIDATE_INIT_DATA_USER_ID_NOT_FOUND = "ID de usuario no encontrado en initData"
FLASK_WEBHOOK_SET_SUCCESS = '¡Webhook configurado!'
FLASK_WEBHOOK_SET_ERROR = "Error al configurar webhook: {error}"

# --- Google API Specific ---
DEBUG_GEMINI_EXTRACT_ATTEMPT = "Intentando extraer texto de la respuesta de Gemini. Tipo: {type}, Contenido: {content_preview}..."
DEBUG_GEMINI_EXTRACT_FAIL_CONTENT = "Contenido problemático de la respuesta de Gemini: {content}"
DEBUG_GEMINI_EXTRACT_FAIL_SNIPPET = "Fragmento de respuesta problemático: {snippet}"
ERROR_FORM_API_UNKNOWN = "Error de API desconocido"
ERROR_FORM_API_STATUS_FALLBACK = "Error de API (Estado: {status_code})"

# --- Telegram Bot Specific ---
WELCOME_MESSAGE_DEFAULT = "Welcome to the bot! Choose an option:" # English default
WELCOME_MESSAGE_DEFAULT_ES = "¡Bienvenido al bot! Elige una opción:" # Spanish version
ERROR_AI_NO_RESPONSE = "El servicio de IA no devolvió respuesta."
LOG_TRIGGER_GEMINI_ERROR = "Error en _trigger_gemini_analysis para el usuario {user_id}: {error}"
LOG_TRIGGER_GEMINI_RECOVERY_FAIL = "Fallo al enviar mensaje de error durante la recuperación de _trigger_gemini_analysis: {nested_error}"
LOG_GEMINI_ANALYSIS_TRUNCATED = "Resultado largo del análisis de Gemini truncado para el usuario {user_id}"
LOG_DATA_ENTRY_DETECTED = "Palabra clave de entrada de datos detectada. Guardando contenido: '{content_preview}...'"
CONFIRM_DATA_ENTRY_SAVED = "Entrada de datos guardada."
LOG_TRIGGER_GEMINI_TEXT_MSG = "Disparando análisis de Gemini para mensaje de texto entrante del usuario {user_id}"
LOG_VIEW_DATA_UNEXPECTED_TYPE = "Tipo inesperado para message_text en view_my_data: {type}, valor: {value_repr}"

# --- Main Script ---
LOG_EFFECTIVE_UID = "UID efectivo: {uid}"
LOG_EFFECTIVE_USER = "Usuario efectivo: {user}"
WARN_CANNOT_GET_USER_INFO = "No se pudo obtener información del usuario: {error}"
FATAL_DB_INIT_FAILED = "FATAL: Fallo al inicializar la base de datos: {error}"
LOG_STARTING_DEBUG_POLLING = "Iniciando bot en modo DEBUG usando polling..."
LOG_REMOVING_WEBHOOK = "Intentando eliminar webhook existente (si lo hay)..."
LOG_WEBHOOK_REMOVED = "Webhook eliminado con éxito (o no estaba configurado)."
WARN_CANNOT_REMOVE_WEBHOOK = "No se pudo eliminar el webhook (puede que no estuviera configurado): {error}"
LOG_POLLING_STARTED = "Polling del bot iniciado..."
ERROR_POLLING_FAILED = "Polling falló: {error}"
LOG_POLLING_STOPPED = "Polling del bot detenido."
LOG_STARTING_PRODUCTION_WEBHOOK = "Iniciando bot en modo PRODUCCIÓN usando webhook..."
FATAL_INVALID_BASE_URL_PRODUCTION = "FATAL: BASE_URL no está configurada, no es HTTPS, o es local en modo producción."
LOG_CURRENT_BASE_URL = "BASE_URL actual: {base_url}"
ERROR_REMOVING_WEBHOOK_PRODUCTION = "Error al eliminar webhook antes de configurar uno nuevo: {error}"
LOG_SETTING_WEBHOOK = "Configurando webhook en: {url}"
WARN_SSL_CERT_NOT_FOUND = "Certificado SSL o Clave no encontrados. Cert: {cert_path}, Key: {key_path}. Configurando webhook sin parámetro de certificado."
LOG_WEBHOOK_SET_NO_CERT_PARAM = "Webhook configurado con éxito (sin enviar parámetro de certificado a Telegram)."
LOG_WEBHOOK_STATUS_CHECK = "Comprobación de estado del webhook: URL='{url}', Actualizaciones pendientes={pending_updates}"
WARN_TELEGRAM_WEBHOOK_ERROR = "Telegram reportó error de webhook: {error_message}"
FATAL_WEBHOOK_SET_API_ERROR = "FATAL: Fallo al configurar webhook debido a error de API de Telegram: {error}"
FATAL_WEBHOOK_SET_OTHER_ERROR = "FATAL: Fallo al configurar webhook debido a otro error: {error}"
LOG_STARTING_FLASK = "Iniciando servidor Flask en 0.0.0.0:{port} con SSL..."
FATAL_SSL_FILES_NOT_FOUND_FLASK = "FATAL: Archivo de certificado o clave SSL no encontrado para el servidor Flask."
LOG_CERT_PATH_CHECKED = "Ruta de certificado comprobada: {path}"
LOG_KEY_PATH_CHECKED = "Ruta de clave comprobada: {path}"
FATAL_PORT_IN_USE = "FATAL: El puerto {port} ya está en uso."
FATAL_FLASK_OS_ERROR = "FATAL: Fallo al iniciar servidor Flask debido a error del SO: {error}"
FATAL_FLASK_START_FAILED = "FATAL: Fallo al iniciar servidor Flask: {error}"

# --- Test E2E Telethon ---
TEST_IMAGE_PATH = "images/cadorna.jpeg" # Path, no translation needed
TEST_IMAGE_CAPTION = "Imagen de prueba"
TEST_EXPECTED_NAME = "cadorna" # Keep as is, likely used for matching
TEST_EXPECTED_FIRST_NAME = "luigi" # Keep as is, likely used for matching
TEST_EXPECTED_TITLE = "general" # Keep as is, likely used for matching
TEST_TEXT_QUERY = "¿Cómo se llama el paciente?" # Already in Spanish
TEST_IMAGE_VALIDATION_TEXT = "Información Extraída" # "Extracted Information"
TEST_IMAGE_PROCESSING_TEXT = "Imagen de prueba" # "Processing your image"

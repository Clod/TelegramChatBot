
# --- General ---
ERROR_GENERIC = "An unexpected error occurred."
ERROR_PROCESSING_REQUEST = "An error occurred processing your request."
ERROR_TRY_AGAIN_LATER = "Please try again later."
OPERATION_CANCELED = "Operation canceled."
ACTION_NOT_RECOGNIZED = "Action not recognized."
BOT_IS_RUNNING = 'Bot is running!'

# --- Configuration Loading ---
LOG_DOTENV_LOADED = ".env file loaded (override=True)"
LOG_RAW_DEBUG_MODE = "Raw DEBUG_MODE string from environment: '{raw_value}'"
LOG_DEBUG_MODE_EVALUATED = "DEBUG_MODE evaluated as: {debug_mode}"
DEBUG_MODE_ON = "Debug mode is ON!"
DEBUG_MODE_OFF = "Debug mode is OFF!"
ERROR_TOKEN_NOT_SET = "TELEGRAM_BOT_TOKEN environment variable is not set"
WARN_BASE_URL_NOT_SET = "BASE_URL environment variable is not set. Attempting to infer..."
WARN_INFERRED_BASE_URL = "Inferred BASE_URL as {base_url}. Set this explicitly in .env for production."
WARN_GOOGLE_CREDS_NOT_SET = "GOOGLE_APPLICATION_CREDENTIALS environment variable is not set or file does not exist. Some Google API features may not work."
WARN_GOOGLE_FORM_ID_NOT_SET = "GOOGLE_FORM_ID could not be retrieved. Form retrieval will not work."
LOG_GOOGLE_FORM_ID_SUCCESS = "GOOLGE_FORM_ID retrieved successfully: {form_id}"
WARN_APPS_SCRIPT_ID_NOT_SET = "APPS_SCRIPT_ID environment variable is not set. Google Sheet retrieval will not work."
LOG_APPS_SCRIPT_ID_SUCCESS = "APPS_SCRIPT_ID retrieved successfully: {script_id}"
WARN_APPS_SCRIPT_WEB_APP_NOT_SET = "APPS_SCRIPT_WEB_APP_URL or APPS_SCRIPT_API_KEY environment variable is not set. Google Sheet retrieval via Web App will not work."
LOG_APPS_SCRIPT_WEB_APP_SUCCESS = "APPS_SCRIPT_WEB_APP_URL retrieved successfully."

# --- Database ---
LOG_DB_INIT_SUCCESS = "Database initialized successfully"
LOG_DB_SAVED_MESSAGE = "Saved message from user {user_id}: {text_preview}..."
LOG_DB_SAVED_MEDIA_MESSAGE = "Saved {message_type} message from user {user_id}"
LOG_DB_SAVED_PROCESSED_TEXT = "Saved '{message_type}' text to user_messages for user {user_id}, original message_id {original_message_id}"
ERROR_DB_SAVING_PROCESSED_TEXT = "Error saving '{message_type}' text to user_messages for user {user_id}: {db_err}"
LOG_DB_DELETED_USER_DATA = "Deleted user data for user_id {user_id}: {messages_deleted} messages, {interactions_deleted} interactions"
ERROR_DB_DELETING_USER_DATA = "Error deleting user data: {error}"
LOG_DB_RETRIEVED_HISTORY = "Retrieved {count} messages for user {user_id}, including processed/retrieved data"
LOG_DB_INITIATING_IMAGE_RESULT_STORAGE = "Initiating database storage for Gemini API response for user_id: {user_id}, message_id: {message_id}"
LOG_DB_IMAGE_RESULT_STORED = "Successfully stored Gemini API response in database (record ID: {record_id})"
ERROR_DB_SAVING_IMAGE_RESULT = "Error saving image processing result to database: {error}"
LOG_DB_SEARCHING_FORM_ID = "Searching for 'form=<ID>' in last {search_limit} messages for user {user_id}"
LOG_DB_FOUND_FORM_ID = "Found response ID: {response_id} in message: '{message_text}'"
WARN_DB_FORM_ID_NOT_FOUND = "Could not find 'form=<ID>' pattern for user {user_id}"
ERROR_DB_RETRIEVING_USERS = "Error retrieving users from DB: {error}"
ERROR_DB_RETRIEVING_IMAGE_RESULTS = "Error retrieving image processing results from DB: {error}"
ERROR_DB_RETRIEVING_MESSAGES = "Error retrieving user messages from DB: {error}"
ERROR_DB_RETRIEVING_INTERACTIONS = "Error retrieving user interactions from DB: {error}"
ERROR_DB_UPDATING_PREFERENCE = "Failed to update preference in DB"
ERROR_DB_HEALTH_CHECK = "Health check DB error: {error}"
DB_STATUS_OK = 'ok'
DB_STATUS_MISSING = 'missing'
DB_STATUS_ERROR = 'error'
DB_DEFAULT_LANGUAGE = 'en'
DB_DEFAULT_THEME = 'default'
DB_ACTION_TYPE_TEXT = 'text'
DB_ACTION_TYPE_PROCESSED_IMAGE = 'processed_text_from_image'
DB_ACTION_TYPE_RETRIEVED_SHEET = 'retrieved_sheet_data'
DB_ACTION_TYPE_RETRIEVED_FORM = 'retrieved_form_data'
DB_MESSAGE_TYPE_TEXT = 'text'
DB_MESSAGE_TYPE_PHOTO = 'photo'
DB_MESSAGE_TYPE_PROCESSED_IMAGE = 'processed_text_from_image'
DB_MESSAGE_TYPE_RETRIEVED_FORM = 'retrieved_form_data'
DB_MESSAGE_TYPE_RETRIEVED_SHEET = 'retrieved_sheet_data'

# --- Google APIs ---
LOG_GETTING_GEMINI_CREDS = "Attempting to get credentials for Gemini API..."
ERROR_SERVICE_ACCOUNT_NOT_FOUND = "Service account file not found at path: {path}"
LOG_TRYING_GEMINI_SCOPE = "Trying Gemini credentials with scope: {scope}"
LOG_REFRESHING_GEMINI_CREDS = "Refreshing Gemini credentials with scope: {scope}"
LOG_GEMINI_TOKEN_SUCCESS = "Successfully obtained Gemini access token starting with: {token_preview}"
WARN_GEMINI_NO_TOKEN = "No token obtained with scope: {scope}"
WARN_GEMINI_FAILED_TOKEN_SCOPE = "Failed to get token with scope {scope}: {error}"
ERROR_GEMINI_ALL_AUTH_FAILED = "All Gemini API authentication attempts failed"
ERROR_GETTING_GEMINI_CREDS = "Error getting Gemini credentials: {error}"
LOG_GETTING_GOOGLE_API_CREDS = "Attempting to get credentials for Google APIs..."
LOG_REQUESTING_GOOGLE_API_CREDS = "Requesting Google API credentials with scopes: {scopes}"
LOG_GOOGLE_API_CREDS_CREATED = "Google API credentials object created from file: {path}"
LOG_REFRESHING_GOOGLE_API_CREDS = "Attempting to refresh Google API credentials..."
LOG_GOOGLE_API_CREDS_REFRESHED = "Google API credentials refreshed successfully."
LOG_GOOGLE_API_TOKEN_SUCCESS = "Obtained Google API access token starting with: {token_preview}"
LOG_GOOGLE_API_TOKEN_EXPIRY = "Token expiry time: {expiry_time}"
LOG_GOOGLE_API_TOKEN_NO_EXPIRY = "Token expiry time not available."
WARN_GOOGLE_API_NO_TOKEN = "Google API credentials refreshed but no token was obtained."
WARN_GOOGLE_API_REFRESH_FAILED = "Token refresh failed, but continuing: {error}"
LOG_GOOGLE_API_CREDS_SUCCESS = "Successfully obtained credentials for Google APIs."
ERROR_GETTING_GOOGLE_API_CREDS = "Error getting Google API credentials: {error}"
LOG_GEMINI_REQUEST_INITIATED = "Initiating Gemini API request for image from user_id: {user_id}"
ERROR_GEMINI_AUTH_FAILED = "Failed to get authenticated credentials for Gemini"
ERROR_GEMINI_AUTH_FAILED_MSG = "Authentication failed."
ERROR_GEMINI_TOKEN_REFRESH_FAILED = "Failed to get access token after refresh for Gemini."
ERROR_GEMINI_TOKEN_REFRESH_FAILED_MSG = "Authentication token refresh failed."
LOG_GEMINI_SENDING_IMAGE = "Sending image data to Gemini API endpoint: {endpoint}"
LOG_GEMINI_USING_TOKEN = "Using token starting with: {token_preview} for image processing"
LOG_GEMINI_RAW_RESPONSE = "Received raw response from Gemini API (Status: {status_code}): {text_preview}..."
LOG_GEMINI_RESPONSE_SUCCESS = "Successfully received response from Gemini API"
LOG_GEMINI_PARSED_SUCCESS = "Successfully parsed JSON response"
ERROR_GEMINI_REQUEST_FAILED = "HTTP request error calling Gemini API: {error}"
ERROR_GEMINI_REQUEST_FAILED_USER_MSG = "Network error communicating with AI service ({status_code}): {error_text_preview}"
ERROR_GEMINI_JSON_DECODE = "Error parsing Gemini JSON response: {error}"
ERROR_GEMINI_JSON_DECODE_USER_MSG = "Received invalid data format from AI service."
ERROR_GEMINI_PROCESSING_IMAGE = "Error processing image with Gemini: {error}"
ERROR_GEMINI_PROCESSING_IMAGE_USER_MSG = "An unexpected error occurred during AI processing."
ERROR_GEMINI_EXTRACT_UNEXPECTED_TYPE = "Unexpected response type for extraction: {type}"
ERROR_GEMINI_EXTRACT_INVALID_FORMAT = "Error: Invalid response format received."
WARN_GEMINI_RESPONSE_BLOCKED = "Gemini response blocked. Reason: {reason}"
GEMINI_RESPONSE_BLOCKED_USER_MSG = "Content blocked by safety filters. Reason: {reason}. Details: {safety_ratings}"
WARN_GEMINI_NO_CANDIDATES = "No candidates or block reason found in Gemini response: {response}"
GEMINI_NO_TEXT_USER_MSG = "No text content found in the AI response."
WARN_GEMINI_NO_TEXT_EXTRACTED = "No text was extracted from the Gemini response parts."
LOG_GEMINI_EXTRACTED_PIPE_FORMAT = "Extracted text appears to be in pipe-separated format."
WARN_GEMINI_EXTRACTED_UNEXPECTED_FORMAT = "Extracted text might not be in the expected pipe-separated format: {text_preview}..."
ERROR_GEMINI_EXTRACTING_TEXT = "Error extracting text from Gemini response: {error}"
ERROR_GEMINI_EXTRACTING_TEXT_USER_MSG = "Error processing AI response content."
LOG_GEMINI_TEXT_ANALYSIS_INITIATED = "Initiating Gemini text analysis for user {user_id}"
ERROR_GEMINI_TEXT_AUTH_FAILED = "Failed to get authenticated credentials for Gemini text analysis"
ERROR_GEMINI_TEXT_TOKEN_MISSING = "Credentials obtained but token is missing after refresh for Gemini text analysis."
ERROR_GEMINI_TEXT_TOKEN_MISSING_MSG = "Authentication token issue."
LOG_GEMINI_TEXT_USING_TOKEN = "Using token starting with: {token_preview} for text analysis"
LOG_GEMINI_TEXT_SENDING_REQUEST = "Sending text analysis request to Gemini API endpoint: {endpoint}"
LOG_GEMINI_TEXT_ANALYSIS_SUCCESS = "Successfully received and extracted Gemini analysis for user {user_id}"
ERROR_GEMINI_TEXT_REQUEST_FAILED = "HTTP request error calling Gemini API for text analysis: {error}"
ERROR_GEMINI_TEXT_JSON_DECODE = "Error parsing Gemini JSON response for text analysis: {error}"
ERROR_GEMINI_TEXT_PROCESSING = "Error processing text with Gemini for user {user_id}: {error}"
ERROR_GEMINI_TEXT_PROCESSING_USER_MSG = "An unexpected error occurred during AI text analysis."
LOG_FORM_RETRIEVAL_INITIATED = "Attempting to retrieve response {response_id} from form {form_id}"
ERROR_FORM_AUTH_FAILED = "Failed to get credentials for Google Forms API."
ERROR_FORM_AUTH_FAILED_MSG = "Authentication failed."
LOG_FORM_RETRIEVAL_SUCCESS = "Successfully retrieved form response {response_id}"
ERROR_FORM_API = "Google Forms API error: {status_code} - {error_message}"
ERROR_FORM_API_USER_MSG = "API Error ({status_code}): {error_message}"
ERROR_FORM_NOT_FOUND_USER_MSG = "Response ID '{response_id}' not found in form '{form_id}'."
ERROR_FORM_PERMISSION_DENIED_USER_MSG = "Permission denied. Ensure the service account has access to the form responses."
ERROR_FORM_UNEXPECTED = "Unexpected error retrieving form response: {error}"
LOG_APPS_SCRIPT_CALL_INITIATED = "Initiating call to Apps Script ID: {script_id}, Function: {function_name}"
LOG_APPS_SCRIPT_PARAMETERS = "Apps Script parameters: {parameters}"
ERROR_APPS_SCRIPT_AUTH_FAILED = "Failed to obtain credentials for Apps Script call."
ERROR_APPS_SCRIPT_AUTH_FAILED_MSG = "Authentication failed. Could not get credentials."
LOG_APPS_SCRIPT_USING_CREDS = "Using credentials for service account: {email}"
LOG_APPS_SCRIPT_CREDS_DETAILS = "Credentials valid: {valid}, Scopes: {scopes}"
LOG_APPS_SCRIPT_BUILDING_SERVICE = "Building Apps Script API service (script, v1)..."
LOG_APPS_SCRIPT_SERVICE_BUILT = "Apps Script API service built successfully."
LOG_APPS_SCRIPT_EXECUTING = "Executing Apps Script function '{function_name}'..."
LOG_APPS_SCRIPT_REQUEST_BODY = "Apps Script request body: {request}"
LOG_APPS_SCRIPT_RESPONSE_RECEIVED = "Received response from Apps Script execution."
LOG_APPS_SCRIPT_RAW_RESPONSE = "Raw Apps Script response: {response}"
ERROR_APPS_SCRIPT_EXECUTION = "Apps Script execution error: Type={error_type}, Message={error_message}"
LOG_APPS_SCRIPT_STACKTRACE = "Apps Script Stacktrace: {stacktrace}"
ERROR_APPS_SCRIPT_EXECUTION_USER_MSG = "Error during script execution: {error_message}"
ERROR_APPS_SCRIPT_AUTH_REQUIRED_USER_MSG = "Authorization error within the Apps Script."
ERROR_APPS_SCRIPT_NOT_FOUND_USER_MSG = "Error within the Apps Script: '{function_name}' or related code not found."
LOG_APPS_SCRIPT_EXECUTION_SUCCESS = "Apps Script execution successful. Result type: {type}"
LOG_APPS_SCRIPT_RESULT = "Apps Script result: {result}"
ERROR_APPS_SCRIPT_HTTP = "HTTP error calling Apps Script API: Status={status_code}, Response={error_content}"
ERROR_APPS_SCRIPT_HTTP_USER_MSG = "API error occurred ({status_code}). Check logs for details."
ERROR_APPS_SCRIPT_HTTP_401_USER_MSG = "Authentication failed (401)."
ERROR_APPS_SCRIPT_HTTP_403_USER_MSG = "Permission denied (403). Ensure Apps Script API is enabled and service account has permission."
ERROR_APPS_SCRIPT_HTTP_404_USER_MSG = "Apps Script project (ID: {script_id}) not found (404)."
ERROR_APPS_SCRIPT_HTTP_429_USER_MSG = "API rate limit exceeded (429)."
ERROR_APPS_SCRIPT_UNEXPECTED = "Unexpected error calling Apps Script: {error}"
ERROR_APPS_SCRIPT_UNEXPECTED_USER_MSG = "An unexpected error occurred while communicating with the Apps Script service."
LOG_WEB_APP_CALL_INITIATED = "Initiating call to Apps Script Web App for ID: {id_to_find}"
ERROR_WEB_APP_NOT_CONFIGURED = "Web App URL or API Key is not configured."
ERROR_WEB_APP_NOT_CONFIGURED_USER_MSG = "Web App retrieval is not configured on the server."
LOG_WEB_APP_MAKING_REQUEST = "Making GET request to Web App URL (parameters omitted for security)"
LOG_WEB_APP_ATTEMPTING_GET = "Attempting requests.get to {target_url} with timeout=30..."
LOG_WEB_APP_GET_COMPLETED = "requests.get call completed. Status code received: {status_code}"
LOG_WEB_APP_RESPONSE_RECEIVED = "Received response from Web App. Status: {status_code}, Content-Type: {content_type}"
LOG_WEB_APP_RAW_RESPONSE = "Raw response text (first 500 chars): {text_preview}"
WARN_WEB_APP_NOT_FOUND = "Web App returned 'Not Found' for ID: {id_to_find}"
WEB_APP_NOT_FOUND_USER_MSG = "ID '{id_to_find}' not found in the Google Sheet."
ERROR_WEB_APP_UNAUTHORIZED = "Web App returned 'Unauthorized'. Check the API Key."
WEB_APP_UNAUTHORIZED_USER_MSG = "Authorization failed. Invalid API Key provided to Web App."
ERROR_WEB_APP_BAD_REQUEST = "Web App returned 'Bad Request'. Check if 'id' parameter is missing or invalid."
WEB_APP_BAD_REQUEST_USER_MSG = "Bad request sent to the Web App (e.g., missing ID)."
LOG_WEB_APP_JSON_PARSED = "Successfully parsed JSON response from Web App for ID: {id_to_find}"
ERROR_WEB_APP_JSON_DECODE = "Failed to decode JSON response from Web App: {error}"
ERROR_WEB_APP_JSON_DECODE_TEXT = "Response text was: {text}"
WEB_APP_INVALID_DATA_USER_MSG = "Received invalid data format from the Web App."
ERROR_WEB_APP_TIMEOUT = "Request to Web App timed out for ID: {id_to_find}"
WEB_APP_TIMEOUT_USER_MSG = "The request to the Web App timed out."
ERROR_WEB_APP_REQUEST_FAILED = "HTTP request error calling Web App: {error}"
WEB_APP_REQUEST_FAILED_USER_MSG = "Network error communicating with the Web App: {error}"
WEB_APP_REQUEST_FAILED_401_USER_MSG = "Web App access denied (401). Check script permissions/deployment."
WEB_APP_REQUEST_FAILED_403_USER_MSG = "Web App forbidden (403). Check API key or script access."
WEB_APP_REQUEST_FAILED_404_USER_MSG = "Web App URL not found (404)."
WEB_APP_REQUEST_FAILED_500_USER_MSG = "Error within the Web App script (500)."
ERROR_WEB_APP_UNEXPECTED = "Unexpected error retrieving data via Web App: {error}"
WEB_APP_UNEXPECTED_USER_MSG = "An unexpected error occurred while contacting the Web App."
GEMINI_PROMPT_IMAGE_ANALYSIS = "Analyze the image and extract the following personal information: full name, date of birth, age, email, phone number, city, state, gender, and preferred contact method. Return the extracted information as a **single string** with **key-value pairs separated by pipe symbols (|)**. The format should be: `key=value|key=value|key=value|...`. Use the following keys: `full_name`, `date_of_birth`, `age`, `email`, `phone_number`, `city`, `state`, `gender`, and `preferred_contact_method`. For example: `full_name=LUIGI CADORNA|date_of_birth=8/2/1962|age=63|email=luigi.cadorna@ymail.com|phone_number=1234567890|city=Buenos Aires|state=JALISCO|gender=Male|preferred_contact_method=Mail` If any piece of information cannot be confidently extracted from the image, leave the corresponding value **empty** (for strings) or `null` (for numbers like age), but still include the key in the output string. For example, if the email is not found, it should be `email=|...` and if the age is not found, it should be `age=null|...`. Ensure the response is **only the single string** with pipe-separated key-value pairs, without any markdown formatting, code blocks, or extraneous text."
GEMINI_PROMPT_TEXT_ANALYSIS = "Analyze the following user messages and check if there are questions or instructions about what you should do. Your response must include the answer(s) to all questions and instructions. Keep your response concise and friendly and ALLWAYS in Spanish:\n\n"
API_SCOPE_CLOUD_PLATFORM = "https://www.googleapis.com/auth/cloud-platform"
API_SCOPE_AI_PLATFORM = "https://www.googleapis.com/auth/aiplatform"
API_SCOPE_GENERATIVE_AI = "https://www.googleapis.com/auth/generative-ai"
API_SCOPE_FORMS_READONLY = "https://www.googleapis.com/auth/forms.responses.readonly"
API_SCOPE_SCRIPT_EXECUTE = "https://www.googleapis.com/auth/script.execute"

# --- Utils ---
LOG_CLEANUP_SKIPPED_NO_PATH = "Cleanup skipped: No file path provided."
LOG_CLEANUP_INITIATED = "Initiating cleanup of temporary file: {path}"
LOG_CLEANUP_SUCCESS = "Successfully deleted temporary file: {path}"
WARN_CLEANUP_NOT_FOUND = "Cleanup skipped: File not found at {path}"
ERROR_CLEANUP_FAILED = "Error cleaning up temporary file {path}: {error}"

# --- Telegram Bot ---
LOG_MENU_GENERATION_DEBUG = "generate_main_menu: DEBUG_MODE={debug_mode}, BASE_URL='{base_url}'"
LOG_MENU_GENERATION_ADDING_WEBAPPS = "generate_main_menu: Conditions met for adding Web App buttons."
LOG_MENU_GENERATION_CHECKING_URL = "Checking Messages URL: {url}"
LOG_MENU_GENERATION_ADDING_BUTTON = "generate_main_menu: Adding '{button_text}' button."
LOG_MENU_GENERATION_ADDING_WEBAPP_BUTTONS = "generate_main_menu: Calling markup.add() with {count} web app button(s)."
WARN_MENU_GENERATION_NO_WEBAPP_BUTTONS = "generate_main_menu: No valid Web App buttons created, skipping markup.add()."
WARN_MENU_GENERATION_NO_HTTPS = "generate_main_menu: BASE_URL is not set or does not use HTTPS. Web App buttons will not be shown."
LOG_MENU_GENERATION_DEBUG_SKIPPING_WEBAPPS = "generate_main_menu: DEBUG_MODE is True, skipping Web App buttons."
LOG_SENT_MAIN_MENU = "Sent main menu as a new message to chat {chat_id}"
ERROR_SENDING_MAIN_MENU = "Failed to send main menu message to chat {chat_id}: {error}"
LOG_IMAGE_DOWNLOAD_START = "Starting image download process for file_id: {file_id}, user_id: {user_id}, message_id: {message_id}"
LOG_IMAGE_DOWNLOAD_SUCCESS = "Successfully downloaded image to {path} (Size: {size} bytes)"
ERROR_IMAGE_DOWNLOAD = "Error downloading image: {error}"
LOG_SENT_GENERATED_FILE = "Sent generated file {filename} to chat {chat_id}"
ERROR_GENERATING_FILE = "Error generating/sending file for chat {chat_id}: {error}"
ERROR_GENERATING_FILE_USER_MSG = "Sorry, couldn't generate or send the file."
LOG_RECEIVED_COMMAND = "Received /{command} command from user {user_id} in chat {chat_id}"
LOG_SENT_WELCOME_MENU = "Sent welcome message with main menu to user {user_id}"
ERROR_START_HELP_FAILED = "Error during handle_start_help for user {user_id}: {error}"
ERROR_START_HELP_USER_MSG = "Sorry, something went wrong. Please try /start again later."
ERROR_SENDING_ERROR_MSG = "Failed to send error message to user {user_id}: {error}"
LOG_RECEIVED_PHOTO = "Received photo from user {user_id} in chat {chat_id}, message_id {message_id}"
PHOTO_NO_DATA_USER_MSG = "I couldn't find any image data in your message."
LOG_PHOTO_NO_DATA = 'photo_message_no_data'
LOG_IMAGE_RECEIVED_DETAILS = "Image received from user {user_id}, message ID {message_id}. File ID: {file_id}"
PHOTO_PROCESSING_USER_MSG = "Processing your image..."
PHOTO_DOWNLOAD_FAILED_USER_MSG = "Sorry, I couldn't download your image."
LOG_DOWNLOAD_IMAGE_ERROR = 'download_image_error'
LOG_IMAGE_PROCESSING_WORKFLOW_START = "Starting image processing workflow for user {user_id}"
PHOTO_PROCESSING_FAILED_USER_MSG = "Sorry, I couldn't process your image. Error: {error_text}"
LOG_GEMINI_PROCESSING_ERROR = 'gemini_processing_error'
LOG_EXTRACTED_TEXT_PREVIEW = "Extracted text from Gemini for user {user_id}: {text_preview}..."
LOG_CONVERTED_TO_JSON = "Successfully converted extracted text to JSON for user {user_id}"
WARN_CONVERSION_INVALID_PAIR = "Skipping invalid pair '{pair}' in Gemini response for user {user_id}"
WARN_CONVERSION_NO_PAIRS = "Could not parse any valid key-value pairs from Gemini response for user {user_id}. Saving original text."
WARN_CONVERSION_NOT_PIPE_SEPARATED = "Extracted text for user {user_id} not pipe-separated. Saving original text."
ERROR_CONVERTING_TO_JSON = "Error converting pipe-separated string to JSON for user {user_id}: {error}"
WARN_FAILED_SAVING_IMAGE_RESULT = "Failed to save image processing result to DB for user {user_id}"
PHOTO_EXTRACTED_INFO_USER_MSG = "Extracted Information:\n\n{result_text}"
WARN_TRUNCATED_MESSAGE = "Truncated long extracted text message for user {user_id}"
LOG_SENT_EXTRACTED_TEXT = 'sent_extracted_text'
LOG_IMAGE_PROCESSING_WORKFLOW_SUCCESS = "Successfully completed image processing workflow for user {user_id}"
PHOTO_PROCESSED_NEXT_ACTION_USER_MSG = "Image processed. What would you like to do next?"
ERROR_IMAGE_WORKFLOW = "Error in image processing workflow: {error}"
PHOTO_ERROR_USER_MSG = "Sorry, an error occurred while processing your image."
LOG_PHOTO_WORKFLOW_ERROR = 'photo_workflow_error'
LOG_IMAGE_WORKFLOW_CLEANUP_COMPLETE = "Completed image processing workflow cleanup for user {user_id}"
TEXT_UNKNOWN_COMMAND_USER_MSG = "Sorry, I don't understand that command."
LOG_SKIPPED_MENU_FOR_COMMAND = "Skipped sending main menu from handle_text for command '{command}' in chat {chat_id}"
TEXT_HISTORY_HEADER = "📝 Your message history:\n\n"
TEXT_HISTORY_NO_PREVIOUS = "No previous messages found."
TEXT_RECEIVED_USER_MSG = "Received your message."
TEXT_RECEIVED_NO_HISTORY_USER_MSG = "Received your message. No history found."
LOG_SENT_MENU_AFTER_TEXT = "Sent main menu after handling non-command text from chat {chat_id}"
LOG_BUTTON_CLICK = "button_click"
LOG_USER_ACTION = "User {user_id}: {action}"
LOG_CALLBACK_RETRIEVE_FORM = "User {user_id}: Clicked 'Retrieve Form Data'"
CALLBACK_FORM_NOT_CONFIGURED = "Form retrieval not configured."
CALLBACK_SEARCHING_FORM_ID = "Searching for form response ID..."
CALLBACK_FORM_ID_NOT_FOUND = "Could not find 'form=<number>' in recent history."
CALLBACK_FOUND_FORM_ID = "Found ID: {response_id}. Retrieving data..."
CALLBACK_FORM_DATA_DISPLAY = "📄 Form Response Data (ID: {response_id}):\n\n```json\n{json_string}\n```"
CALLBACK_FORM_DATA_TRUNCATED = "... (truncated)\n```"
ERROR_DISPLAYING_FORM_DATA = "Error formatting/displaying form data: {error}"
CALLBACK_FORM_DISPLAY_ERROR_USER_MSG = "Retrieved data for {response_id}, but failed to display."
CALLBACK_FORM_RETRIEVAL_FAILED_USER_MSG = "❌ Failed to retrieve form data:\n{error_message}"
LOG_FORM_RETRIEVAL_SUCCESS = "form_retrieval_success"
LOG_FORM_RETRIEVAL_FAILED = "form_retrieval_failed"
LOG_CALLBACK_RETRIEVE_SHEET = "User {user_id}: Clicked 'Retrieve Sheet Data'"
CALLBACK_SHEET_NOT_CONFIGURED = "Sheet retrieval via Web App not configured."
CALLBACK_SEARCHING_SHEET_ID = "Searching for ID (form=<number>)..."
LOG_CALLING_WEB_APP = "Calling get_sheet_data_via_webapp for ID: {id_to_find}"
CALLBACK_SHEET_DATA_DISPLAY = "📈 Sheet Data (ID: {id_to_find}):\n\n```json\n{json_string}\n```"
ERROR_DISPLAYING_SHEET_DATA = "Error formatting/displaying sheet data: {error}"
CALLBACK_SHEET_DISPLAY_ERROR_USER_MSG = "Retrieved sheet data for {id_to_find}, but failed to display."
CALLBACK_SHEET_RETRIEVAL_FAILED_USER_MSG = "❌ Failed to retrieve sheet data:\n{error_message}"
LOG_SHEET_RETRIEVAL_SUCCESS = "sheet_retrieval_success"
LOG_SHEET_RETRIEVAL_FAILED = "sheet_retrieval_failed"
LOG_CALLBACK_VIEW_DATA = "User {user_id}: Requested to view their data"
CALLBACK_DATA_SUMMARY_HEADER = "📊 Your Data Summary\n\nProfile:\n"
CALLBACK_DATA_SUMMARY_PROFILE = "• Username: @{username}\n• Name: {first_name} {last_name}\n• Joined: {created_at}\n\nPreferences:\n"
CALLBACK_DATA_SUMMARY_PREFS = "• Language: {language}\n\nActivity:\n"
CALLBACK_DATA_SUMMARY_ACTIVITY = "• Messages: {message_count}\n• Interactions: {interaction_count}\n\nRecent Messages:\n"
CALLBACK_DATA_SUMMARY_RECENT_MSG = "{index}. {text_preview}{ellipsis}\n"
CALLBACK_DATA_SUMMARY_NO_RECENT = "None\n"
CALLBACK_DATA_SUMMARY_NO_TEXT = "[No Text/Media]" # Placeholder for None message text
CALLBACK_NO_DATA_FOUND = "No data found."
LOG_CALLBACK_DELETE_DATA = "User {user_id}: Requested data deletion"
CALLBACK_DELETE_CONFIRMATION_USER_MSG = "⚠️ Sure you want to delete all data? Cannot be undone."
LOG_CALLBACK_CONFIRM_DELETE = "User {user_id}: Confirmed data deletion"
CALLBACK_DELETE_SUCCESS_USER_MSG = "✅ Data deleted ({msg_del} msgs, {int_del} interactions). Use /start again."
CALLBACK_DELETE_SUCCESS_NEXT_ACTION = "Data deleted. Choose an option:"
CALLBACK_DELETE_ERROR_USER_MSG = "❌ Error deleting data."
LOG_CALLBACK_CANCEL_DELETE = "User {user_id}: Canceled data deletion"
LOG_CALLBACK_MENU1 = "User {user_id}: Menu 1 (Analyze Messages) selected"
CALLBACK_ANALYZING_MESSAGES = "Analyzing messages..."
CALLBACK_NO_MESSAGES_TO_ANALYZE = "No messages to analyze."
CALLBACK_ANALYSIS_PROMPT_JSON = "- JSON Data: {formatted_json}\n"
CALLBACK_ANALYSIS_PROMPT_TEXT = "- {text}\n"
LOG_SENDING_PROMPT_TO_GEMINI = "Sending prompt to Gemini for analysis (user {user_id}): {prompt_preview}..."
CALLBACK_ANALYSIS_ERROR_USER_MSG = "Sorry, couldn't analyze messages. Error: {error_text}"
CALLBACK_ANALYSIS_RESULT_USER_MSG = "📊 Analysis:\n\n{analysis_result}"
LOG_CALLBACK_MENU2 = "User {user_id}: Menu 2 selected"
CALLBACK_MENU2_USER_MSG = "Selected Menu 2. Choose subitem:"
LOG_CALLBACK_MAIN_MENU = "User {user_id}: Returned to main menu"
CALLBACK_MAIN_MENU_USER_MSG = "Main Menu:"
LOG_CALLBACK_SUBMENU = "User {user_id}: Processing {callback_data}"
CALLBACK_PROCESSING_SUBMENU = "Processing {callback_data}..."
CALLBACK_SUBMENU_PROCESSED_NEXT_ACTION = "{callback_data} processed. Choose next option:"
CALLBACK_SUBMENU_ACTION_PROCESSED = "Action '{callback_data}' processed."
WARN_UNHANDLED_CALLBACK = "Unhandled callback data from user {user_id}: {callback_data}"
WARN_EDIT_MESSAGE_NOT_FOUND = "Could not edit message {message_id} for chat {chat_id}. It might have been deleted or is too old. Sending new message instead."
CALLBACK_DEFAULT_USER_MSG = "Please choose an option:"
ERROR_CALLBACK_API = "Telegram API error handling callback '{callback_data}' for user {user_id}: {api_ex}"
ERROR_CALLBACK_API_USER_MSG = "Sorry, a Telegram error occurred."
ERROR_CALLBACK_GENERAL = "Error handling callback query '{callback_data}' for user {user_id}: {error}"
ERROR_CALLBACK_GENERAL_USER_MSG = "An error occurred processing your request."
ERROR_CALLBACK_GENERAL_EDIT_MSG = "An error occurred. Please try again."
ERROR_SENDING_CALLBACK_FEEDBACK = "Failed to send error feedback for callback '{callback_data}' to user {user_id}: {nested_error}"
BUTTON_ANALYZE_MESSAGES = "📊 Analyze My Messages"
BUTTON_RETRIEVE_FORM = "📄 Retrieve Form Data"
BUTTON_RETRIEVE_SHEET = "📈 Retrieve Sheet Data"
BUTTON_MENU2 = "Menu 2"
BUTTON_VIEW_DATA = "📊 View My Data"
BUTTON_DELETE_DATA = "🗑️ Delete My Data"
BUTTON_EDIT_MESSAGES = "📝 Edit My Messages"
BUTTON_SUBITEM_1 = "{menu_id} Subitem 1"
BUTTON_SUBITEM_2 = "{menu_id} Subitem 2"
BUTTON_BACK_MAIN_MENU = "Back to Main Menu"
BUTTON_CONFIRM_DELETE = "✅ Yes, Delete My Data"
BUTTON_CANCEL_DELETE = "❌ No, Keep My Data"
CALLBACK_DATA_MENU1 = "menu1"
CALLBACK_DATA_RETRIEVE_FORM = "retrieve_form"
CALLBACK_DATA_RETRIEVE_SHEET = "retrieve_sheet_data"
CALLBACK_DATA_MENU2 = "menu2"
CALLBACK_DATA_VIEW_DATA = "view_my_data"
CALLBACK_DATA_DELETE_DATA = "delete_my_data"
CALLBACK_DATA_SUBITEM_1 = "{menu_id}_sub1"
CALLBACK_DATA_SUBITEM_2 = "{menu_id}_sub2"
CALLBACK_DATA_MAIN_MENU = "main_menu"
CALLBACK_DATA_CONFIRM_DELETE = "confirm_delete"
CALLBACK_DATA_CANCEL_DELETE = "cancel_delete"
USER_STATE_MAIN_MENU = 'main_menu'
USER_STATE_DELETE_CONFIRMATION = 'delete_confirmation'
USER_STATE_MENU1 = 'menu1'
USER_STATE_MENU2 = 'menu2'

# --- Flask App ---
LOG_WEBHOOK_RECEIVED = "Received update via webhook: {json_preview}..."
ERROR_WEBHOOK_PROCESSING = "Error processing webhook update: {error}"
LOG_WEBHOOK_SET = "Webhook set to {url}"
ERROR_WEBHOOK_SET = "Error setting webhook: {error}"
ERROR_WEBHOOK_INFO = "Error getting webhook info: {error}"
ERROR_CHECK_UPDATES = "Error checking updates manually: {error}"
ERROR_USER_NOT_FOUND = 'User not found'
ERROR_UPDATING_PREFERENCE = "Error updating preference via route: {error}"
ERROR_MISSING_PREFERENCE_FIELDS = 'Missing required fields'
ERROR_INVALID_PREFERENCE_NAME = 'Invalid preference name. Must be one of: {valid_prefs}'
PREFERENCE_UPDATE_SUCCESS = 'Preference {pref_name} updated'
LOG_SERVING_EDIT_MESSAGES_HTML = "Serving edit_messages.html for Web App request"
LOG_WEBAPP_GET_MESSAGES_REQUEST = "Received request for /webapp/get_messages"
WARN_WEBAPP_MISSING_INIT_DATA = "Missing X-Telegram-Init-Data header for {route}"
ERROR_WEBAPP_AUTH_REQUIRED = 'Authentication required'
ERROR_WEBAPP_INVALID_AUTH_DATA = 'Invalid authentication data'
LOG_WEBAPP_FETCHING_MESSAGES = "Fetching messages for validated user_id: {user_id}"
LOG_WEBAPP_FETCHED_MESSAGES = "Successfully fetched {count} text messages for user_id: {user_id}"
ERROR_WEBAPP_FETCHING_MESSAGES = "Error fetching messages for web app: {error}"
ERROR_WEBAPP_INTERNAL_SERVER = 'Internal server error'
LOG_WEBAPP_SAVE_MESSAGES_REQUEST = "Received request for /webapp/save_messages"
LOG_WEBAPP_PROCESSING_SAVE = "Processing save_messages request for validated user_id: {user_id}"
WARN_WEBAPP_INVALID_SAVE_DATA = "Invalid JSON data received in save_messages for user_id: {user_id}"
ERROR_WEBAPP_INVALID_DATA_FORMAT = 'Invalid data format'
LOG_WEBAPP_SKIPPING_INVALID_ITEM = "Skipping invalid item format in save_messages for user {user_id}: {item}"
ERROR_WEBAPP_INVALID_ITEM_FORMAT = "Invalid item format: {item}"
WARN_WEBAPP_UPDATE_FAILED = "Failed to update message db_id {db_id} for user {user_id}."
ERROR_WEBAPP_MESSAGE_NOT_FOUND = "Message ID {db_id} not found or doesn't belong to user."
LOG_WEBAPP_FINISHED_SAVING = "Finished saving messages for user_id: {user_id}. Success: {success_count}, Failed: {fail_count}"
ERROR_WEBAPP_DB_TRANSACTION = "DB transaction error saving messages for user_id {user_id}: {error}"
WEBAPP_SAVE_STATUS_SUCCESS = 'success'
WEBAPP_SAVE_STATUS_PARTIAL = 'partial_error'
WEBAPP_SAVE_STATUS_ERROR = 'error'
WEBAPP_SAVE_MESSAGE_PARTIAL = 'Failed to save {fail_count} message(s).'
WEBAPP_SAVE_ERROR_TRANSACTION = "Transaction failed: {error}"
HEALTH_CHECK_BOT_ERROR = "Health check bot error: {error}"
HEALTH_CHECK_DB_ERROR = "Health check DB error: {error}"

# --- Main Script ---
LOG_EFFECTIVE_UID = "Effective UID: {uid}"
LOG_EFFECTIVE_USER = "Effective User: {user}"
WARN_CANNOT_GET_USER_INFO = "Could not get user info: {error}"
FATAL_DB_INIT_FAILED = "FATAL: Failed to initialize database: {error}"
LOG_STARTING_DEBUG_POLLING = "Starting bot in DEBUG mode using polling..."
LOG_REMOVING_WEBHOOK = "Attempting to remove existing webhook (if any)..."
LOG_WEBHOOK_REMOVED = "Webhook removed successfully (or was not set)."
WARN_CANNOT_REMOVE_WEBHOOK = "Could not remove webhook (may not have been set): {error}"
LOG_POLLING_STARTED = "Bot polling started..."
ERROR_POLLING_FAILED = "Polling failed: {error}"
LOG_POLLING_STOPPED = "Bot polling stopped."
LOG_STARTING_PRODUCTION_WEBHOOK = "Starting bot in PRODUCTION mode using webhook..."
FATAL_INVALID_BASE_URL_PRODUCTION = "FATAL: BASE_URL is not set, not HTTPS, or is local in production mode."
LOG_CURRENT_BASE_URL = "Current BASE_URL: {base_url}"
ERROR_REMOVING_WEBHOOK_PRODUCTION = "Error removing webhook before setting new one: {error}"
LOG_SETTING_WEBHOOK = "Setting webhook to: {url}"
WARN_SSL_CERT_NOT_FOUND = "SSL Certificate or Key not found. Cert: {cert_path}, Key: {key_path}. Setting webhook without certificate parameter."
LOG_WEBHOOK_SET_NO_CERT_PARAM = "Webhook set successfully (without sending certificate parameter to Telegram)."
LOG_WEBHOOK_STATUS_CHECK = "Webhook status check: URL='{url}', Pending Updates={pending_updates}"
WARN_TELEGRAM_WEBHOOK_ERROR = "Telegram reported webhook error: {error_message}"
FATAL_WEBHOOK_SET_API_ERROR = "FATAL: Failed to set webhook due to Telegram API error: {error}"
FATAL_WEBHOOK_SET_OTHER_ERROR = "FATAL: Failed to set webhook due to other error: {error}"
LOG_STARTING_FLASK = "Starting Flask server on 0.0.0.0:{port} with SSL..."
FATAL_SSL_FILES_NOT_FOUND_FLASK = "FATAL: SSL certificate or key file not found for Flask server."
LOG_CERT_PATH_CHECKED = "Cert path checked: {path}"
LOG_KEY_PATH_CHECKED = "Key path checked: {path}"
FATAL_PORT_IN_USE = "FATAL: Port {port} is already in use."
FATAL_FLASK_OS_ERROR = "FATAL: Failed to start Flask server due to OS error: {error}"
FATAL_FLASK_START_FAILED = "FATAL: Failed to start Flask server: {error}"

# --- Test E2E Telethon ---
# Excluded as requested
